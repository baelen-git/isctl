// Code generated by generator-postprocess; DO NOT EDIT.

package main

import (
    "fmt"
    "net/http"
    "regexp"
    "reflect"
    "log"
    "encoding/json"

    "github.com/cgascoig/isctl/openapi"
)

{{ define "cliitem" }}
{{ if .Operation }}
    type {{ .Operation.OperationID }} struct {
    {{ if ne .BodyParamType "" }}body *openapi.{{ .BodyParamType }}{{ end }}
    }

    {{ if ne .BodyParamType "" }}
    func (o *{{ .Operation.OperationID }}) GetBody() *openapi.{{ .BodyParamType }} {
        if o.body == nil {
            o.body = openapi.New{{ .BodyParamType }}(
                {{ $classid := .Operation.ReturnBaseType }}
                {{ range .RequiredBodyParamVars }}
                    {{ if .Required }}{{ if eq .Name "ObjectType" "ClassId" }}"{{ $classid }}",{{ end }}{{ end }}
                {{ end }}
                )
            
            //Set class id and object type by default
            o.body.ClassId = "{{ .Operation.ReturnBaseType }}"
            o.body.ObjectType = "{{ .Operation.ReturnBaseType }}"
        }

        return o.body
    }
    {{ end }}

    func (o *{{ .Operation.OperationID }}) SetBodyParams(client *openapi.APIClient, params map[string]interface{}) error {
        {{ if ne .BodyParamType "" }}
        body := o.GetBody()

        log.Printf("SetBodyParams: input params: %v", params)

        {{ range .BodyParamVars }}
        {{ if eq .DataType "string" "bool" "[]string" }}{{ else if not .Ignore }}
            if v, ok := params["{{ .Name }}"]; ok && isMoRef(openapi.{{ .DataType }}{}) {
                if refStr, ok := v.(string); ok {
                    paramVal := openapi.{{ .DataType }}{}

                    filter, isMoFilter := parseMoRef(refStr)
                    if isMoFilter {
                        ok := setMoMoRefByFilter(client, &paramVal, "{{ .DataType }}", filter)

                        if ok {
                            //body.{{ .Name }} = {{ if not .Nullable }}&{{ end }}paramVal
                            params["{{ .Name }}"] = &paramVal
                        } else {
                            return fmt.Errorf("Error retreiving relationship: %s", refStr)
                        }
                    } else {
                        return fmt.Errorf("Error parsing relationship: %s", refStr)
                    }
                }
            }
        {{ end }}
        {{ end }}

        log.Printf("SetBodyParams: after relationship resolving: %v", params)

        jsTmp, err := json.Marshal(params)
        if err != nil {
            return fmt.Errorf("SetBodyParams: Error marshalling JSON: %v", err)
        }

        log.Printf("SetBodyParams: intermediary JSON: %s", jsTmp)
        
        err = json.Unmarshal(jsTmp, body)
        if err != nil {
            return fmt.Errorf("SetBodyParams: Error unmarshalling JSON: %v", err)
        }

        //o.body = body
        return nil
        {{ else }}return nil{{ end }}
    }

    func (o *{{ .Operation.OperationID }}) Execute(client *openapi.APIClient, args []string, queryParams map[string]string) (interface{}, *http.Response, error) {
        req := client.{{ .Operation.BaseName }}Api.{{ .Operation.OperationID }}(authCtx{{ if .Parameter }}, args[0]{{ end }})

        {{ if ne .BodyParamType "" }}log.Printf("o.body: %v", o.body)
        req = req.{{ .BodyParamType }}(*o.body){{ end }}

        {{ if eq .Operation.HTTPMethod "Get" }}
            {{ if not .Parameter }}
                if filter, ok := queryParams["filter"]; ok && filter != "" {
                    req = req.Filter(filter)
                }

                if name, ok := queryParams["name"]; ok && name != "" {
                    req = req.Filter(fmt.Sprintf("Name eq '%s'", name))
                }
            {{ end }}
        {{ end }}

        {{ if ne .Operation.ReturnType "" }}
        res, httpResponse, err := req.Execute()
        return res, httpResponse, err
        {{ else }}
        httpResponse, err := req.Execute()
        return nil, httpResponse, err
        {{ end }}
    }
{{ end }}

{{ range $k, $v := .Children }}{{ template "cliitem" $v}}{{ end }}
{{ end }}

{{ template "cliitem" .CliTree }}

func toStringSlice(in []interface{}) ([]string) {
    ret :=[]string{}

    for _, el := range in {
        if s, ok := el.(string); ok {
            ret = append(ret, s)
        } else {
            return nil
        }
    }

    return ret
}

func setMoMoRefByName(client *openapi.APIClient, v interface{}, relationship string, name string) bool {
    return setMoMoRefByFilter(client, v, relationship, fmt.Sprintf("Name eq '%s'", name))
}

func setMoMoRefByFilter(client *openapi.APIClient, v interface{}, relationship string, filter string) bool {
    if !isMoRef(v) {
        return false
    }

    log.Printf("Looking up MoMoRef %s with filter %s", relationship, filter)

    moref := new(openapi.MoMoRef)
    moref.ClassId = "mo.MoRef"

    op := getOperationForRelationship(relationship)
    res, _, err := op.Execute(client, nil, map[string]string{"filter": filter})
    if err != nil {
        log.Printf("Error executing lookup query: %v", err)
        return false
    }

    moid, ok := getMoid(res)
    if !ok {
        return false
    }

    log.Printf("Got Moid %s", moid)

    moref.Moid = &moid

    val := reflect.ValueOf(v).Elem()

    // Here we are trying to find the type of the field other than MoMoRef (e.g. OrganizationOrganization)
    // i.e. the type that this MoRef refers to
    t := val.Type()
    var referredTypeName string
    for i := 0; i < t.NumField(); i++ {
        if t.Field(i).Name == "MoMoRef" {
            continue
        }
        referredTypeName = t.Field(i).Type.Elem().Name()
    }

    moref.ObjectType = goTypeNameToIntersightClassID[referredTypeName]

    val.FieldByName("MoMoRef").Set(reflect.ValueOf(moref))

    return true
}

// getMoid takes a "<objecttype>.List" structure, checks there was exactly 1 match and returns the Moid of that match
func getMoid(res interface{}) (string, bool) {
    val := reflect.Indirect(reflect.ValueOf(res))
	valType := val.Type()
	if valType.Kind() != reflect.Struct {
        log.Printf("getMoid: res not struct")
		return "", false
	}

    // Find the ...List field
    r := regexp.MustCompile(`List$`)
    var listFieldName string
    for i:=0; i<valType.NumField(); i++ {
        if r.MatchString(valType.Field(i).Name) {
            listFieldName = valType.Field(i).Name
        }
    }

    if listFieldName == "" {
        log.Printf("getMoid: no ...List field")
        return "", false
    }

    listStruct := reflect.Indirect(val.FieldByName(listFieldName))

    if listStruct.Kind() != reflect.Struct {
        log.Printf("getMoid: ..List not struct")
		return "", false
	}

	_, ok := listStruct.Type().FieldByName("Results")
    if !ok {
        log.Printf("getMoid: no Results field (original res: %+v)", res)
        return "", false
    }

    results := listStruct.FieldByName("Results")
    if results.Kind() != reflect.Slice && results.Kind() != reflect.Array {
        log.Printf("getMoid: Results field not slice/array")
        return "", false
    }

    if results.Len() != 1 {
        log.Printf("getMoid: number of results doesn't exactly equal 1")
        return "", false
    }

    result := results.Index(0)
    if result.Kind() != reflect.Struct {
        log.Printf("getMoid: single result is not struct")
        return "", false
    }

    if _, ok := result.Type().FieldByName("Moid"); !ok {
        log.Printf("getMoid: single result doesn't have Moid field")
        return "", false
    }

    return reflect.Indirect(result.FieldByName("Moid")).String(), true
}

func getOperationForRelationship(relationship string) Operation {
    r := regexp.MustCompile(`Relationship$`)
    relationship = r.ReplaceAllString(relationship, "Response")
    switch relationship {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsListOperation }}
        case "{{ .ReturnType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}