// Code generated by generator-postprocess; DO NOT EDIT.

package main

import (
    "fmt"
    "net/http"
    "regexp"
    "log"
    "encoding/json"
    "reflect"

    "github.com/cgascoig/isctl/openapi"
)

{{ define "cliitem" }}
{{ if .Operation }}
    type {{ .Operation.OperationID }} struct {
    {{ if ne .BodyParamType "" }}body *openapi.{{ .BodyParamType }}{{ end }}
    }

    {{ if ne .BodyParamType "" }}
    func (o *{{ .Operation.OperationID }}) GetBody() *openapi.{{ .BodyParamType }} {
        if o.body == nil {
            o.body = openapi.New{{ .BodyParamType }}(
                {{ $classid := .Operation.ReturnBaseType }}
                {{ range .RequiredBodyParamVars }}
                    {{ if .Required }}{{ if eq .Name "ObjectType" "ClassId" }}"{{ $classid }}",{{ end }}{{ end }}
                {{ end }}
                )
            
            //Set class id and object type by default
            o.body.ClassId = "{{ .Operation.ReturnBaseType }}"
            o.body.ObjectType = "{{ .Operation.ReturnBaseType }}"
        }

        return o.body
    }
    {{ end }}

    func (o *{{ .Operation.OperationID }}) GetReferencedClasses(params map[string]interface{}) ([]string, error) {
        {{ if ne .BodyParamType "" }}
        ret := []string{}
        {{ range .BodyParamVars }}
        {{ if eq .DataType "string" "bool" "[]string" }}{{ else }}{{ if not .Ignore }}
            if v, ok := params["{{ .Name }}"]; ok && isMoRef(openapi.{{ .DataType }}{}) {
                if refStr, ok := v.(string); ok {
                    paramVal := openapi.{{ .DataType }}{}

                    if _, _, isMoFilter := parseMoRef(refStr); isMoFilter {
                        ret = append(ret, goTypeNameToIntersightClassID[getReferredTypeName(reflect.ValueOf(paramVal).Type())])
                    }
                }
            }
        {{ end }}{{ if .IsList }}
            // handle list
            if v, ok := params["{{ .Name }}"]; ok && isMoRef(openapi.{{ .ListElementType }}{}) {
                if l, ok := v.([]interface{}); ok {
                    for _, item := range l {
                        if refStr, ok := item.(string); ok {
                            paramVal := openapi.{{ .ListElementType }}{}

                            _, _, isMoFilter := parseMoRef(refStr)
                            if isMoFilter {
                                ret = append(ret, goTypeNameToIntersightClassID[getReferredTypeName(reflect.ValueOf(paramVal).Type())])
                            }
                        }
                    }
                }
            }
        {{ end }}
        {{ end }}
        {{ end }}

        return ret, nil
        {{ else }}return []string{}, nil{{ end }}
    }


    func (o *{{ .Operation.OperationID }}) SetBodyParams(client *openapi.APIClient, params map[string]interface{}) error {
        {{ if ne .BodyParamType "" }}
        body := o.GetBody()

        log.Printf("SetBodyParams: input params: %v", params)

        {{ range .BodyParamVars }}
        {{ if eq .DataType "string" "bool" "[]string" }}{{ else }}{{ if not .Ignore }}
            if v, ok := params["{{ .Name }}"]; ok && isMoRef(openapi.{{ .DataType }}{}) {
                if refStr, ok := v.(string); ok {
                    paramVal := openapi.{{ .DataType }}{}

                    filter, datatype, isMoFilter := parseMoRef(refStr)
                    if isMoFilter {
                        var ok bool
                        if datatype != "" {
                            ok = setMoMoRefByFilter(client, &paramVal, datatype, filter)
                        } else {
                            ok = setMoMoRefByFilter(client, &paramVal, "{{ .DataType }}", filter)
                        }

                        if ok {
                            params["{{ .Name }}"] = &paramVal
                        } else {
                            return fmt.Errorf("Error retreiving relationship: %s", refStr)
                        }
                    } else {
                        return fmt.Errorf("Error parsing relationship: %s", refStr)
                    }
                }
            }
        {{ end }}{{ if .IsList }}
            // handle list
            if v, ok := params["{{ .Name }}"]; ok && isMoRef(openapi.{{ .ListElementType }}{}) {
                fmt.Printf("List {{ .Name }} a %#v\n", v)
                if l, ok := v.([]interface{}); ok {
                    fmt.Printf("List {{ .Name }} b\n")
                    newList := []interface{}{}
                    for _, item := range l {
                        if refStr, ok := item.(string); ok {
                            fmt.Printf("List {{ .Name }} c\n")
                            paramVal := openapi.{{ .ListElementType }}{}

                            filter, datatype, isMoFilter := parseMoRef(refStr)
                            if isMoFilter {
                                fmt.Printf("List {{ .Name }} d\n")
                                var ok bool
                                if datatype != "" {
                                    ok = setMoMoRefByFilter(client, &paramVal, datatype, filter)
                                } else {
                                    ok = setMoMoRefByFilter(client, &paramVal, "{{ .ListElementType }}", filter)
                                }

                                if ok {
                                    fmt.Printf("List {{ .Name }} e\n")
                                    newList = append(newList, &paramVal)
                                } else {
                                    return fmt.Errorf("Error retreiving relationship: %s", refStr)
                                }
                            } else {
                                return fmt.Errorf("Error parsing relationship: %s", refStr)
                            }
                        } else {
                            newList = append(newList, item)
                        }
                    }
                    params["{{ .Name }}"] = newList
                }
            }
        {{ end }}
        {{ end }}
        {{ end }}

        log.Printf("SetBodyParams: after relationship resolving: %v", params)

        jsTmp, err := json.Marshal(params)
        if err != nil {
            return fmt.Errorf("SetBodyParams: Error marshalling JSON: %v", err)
        }

        log.Printf("SetBodyParams: intermediary JSON: %s", jsTmp)
        
        err = json.Unmarshal(jsTmp, body)
        if err != nil {
            return fmt.Errorf("SetBodyParams: Error unmarshalling JSON: %v", err)
        }

        //o.body = body
        return nil
        {{ else }}return nil{{ end }}
    }

    func (o *{{ .Operation.OperationID }}) Execute(client *openapi.APIClient, args []string, queryParams map[string]string) (interface{}, *http.Response, error) {
        req := client.{{ .Operation.BaseName }}Api.{{ .Operation.OperationID }}(authCtx{{ if .Parameter }}, args[0]{{ end }})

        {{ if ne .BodyParamType "" }}log.Printf("o.body: %v", o.body)
        req = req.{{ .BodyParamType }}(*o.body){{ end }}

        {{ if eq .Operation.HTTPMethod "Get" }}
            {{ if not .Parameter }}
                if filter, ok := queryParams["filter"]; ok && filter != "" {
                    req = req.Filter(filter)
                }

                if name, ok := queryParams["name"]; ok && name != "" {
                    req = req.Filter(fmt.Sprintf("Name eq '%s'", name))
                }
            {{ end }}
        {{ end }}

        {{ if ne .Operation.ReturnType "" }}
        res, httpResponse, err := req.Execute()
        return res, httpResponse, err
        {{ else }}
        httpResponse, err := req.Execute()
        return nil, httpResponse, err
        {{ end }}
    }
{{ end }}

{{ range $k, $v := .Children }}{{ template "cliitem" $v}}{{ end }}
{{ end }}

{{ template "cliitem" .CliTree }}


func getOperationForRelationship(relationship string) Operation {
    r := regexp.MustCompile(`Relationship$`)
    relationship = r.ReplaceAllString(relationship, "Response")
    switch relationship {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsListOperation }}
        case "{{ .ReturnType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func getGetOperationForClassID(classID string) Operation {
    classID = fmt.Sprintf("%s.Response", classID)
    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsListOperation }}
        case "{{ .ReturnBaseType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func getUpdateOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsUpdateOperation }}
        case "{{ .ReturnBaseType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func getCreateOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsCreateOperation }}
        case "{{ .ReturnBaseType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}