// Code generated by generator-postprocess; DO NOT EDIT.

package main

import (
	"fmt"
	"net/http"
	"reflect"

    log "github.com/sirupsen/logrus"
    "github.com/cgascoig/isctl/openapi"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)


{{ define "cliitem" }}
func () *cobra.Command {
    {{ range .BodyParamVars }}
        {{ if eq .DataType "string" "bool" "[]string" }}
            var {{ .Name }} {{ .DataType }}
        {{ else }}
            //Skipping var {{ .Name }} with unknown data type {{ .DataType }}
        {{ end }}
    {{ end }}
    cmd := &cobra.Command{
        Use: "{{ .Token }}",
        {{ if .Operation }}
        Run: func(cmd *cobra.Command, args []string) {
            client.GetConfig().Debug = verbose

            {{ if eq .Parameter "name" }}
            // Lookup moid from name
            getOp := getGetOperationForClassID("{{ .Operation.OperationClassID }}")
            if getOp == nil {
                resultHandler(nil, nil, fmt.Errorf("FATAL: No operation to lookup Moid from '{{ .Operation.OperationClassID }}'"))
                return
            }
            res, _, err := getOp.Execute(client, nil, map[string]string{"filter": fmt.Sprintf("Name eq '%s'", args[0])})
            if err != nil {
                resultHandler(nil, nil, fmt.Errorf("Error executing query to lookup Moid from Name: %v", err))
                return 
            }

            moid, ok := getMoid(res)
            if !ok {
                resultHandler(nil, nil, fmt.Errorf("Error executing query to lookup Moid from Name: number of results must exactly equal 1"))
                return 
            }

            args = []string{moid}
            {{ end }}

            bodyParamMap := map[string]interface{}{}

            bodyFormat, err := cmd.Flags().GetString("bodyformat")
            if err == nil && bodyFormat != "" {
                err = readBody(bodyFormat, &bodyParamMap)
                if err != nil {
                    resultHandler(nil, nil, fmt.Errorf("Error reading body from standard input: %v", err))
                    return
                }
            }

            operation := {{ .Operation.OperationID }}{}

            flagSetToMap(cmd.Flags(), &bodyParamMap)
            if err = operation.SetBodyParams(client, bodyParamMap); err != nil {
                resultHandler(nil, nil, fmt.Errorf("Generating API body: %v", err))
                return
            }

            queryParams := map[string]string{}
            {{ if eq .Operation.HTTPMethod "Get" }}
                {{ if not .Parameter }}
                    queryParams = getQueryParams(cmd.Flags())
                {{ end }}
            {{ end }}

            res, httpResponse, err := operation.Execute(client, args, queryParams)
            resultHandler(res, httpResponse, err)
        }, 
        {{ end }}
        {{ if .Parameter }}
        Args: cobra.ExactArgs(1),
        {{ end }}
        
        Short: "{{ .Help }}",
        Long: `{{ .Help }}
{{ if ne .BodyParamType "" }}
Provide resource body as JSON on standard input{{ end }}`,
    }
    
    {{ range $k, $v := .Children }}
        cmd.AddCommand({{ template "cliitem" $v}}())
    {{ end }}

    {{ if ne .BodyParamType "" }}
        cmd.Flags().String("bodyformat", "", "Format of request body passed on stdin (e.g. \"json\"). Default: don't read from stdin")
    {{ end }}

    {{ range .BodyParamVars }}
        {{ if eq .DataType "string" }}
            cmd.Flags().StringVar(&{{ .Name }}, "{{ .Name }}", "", "{{ .Name }}")
        {{ else if eq .DataType "bool" }}
            cmd.Flags().BoolVar(&{{ .Name }}, "{{ .Name }}", false, "{{ .Name }}")
        {{ else if eq .DataType "[]string" }}
            cmd.Flags().StringSliceVar(&{{ .Name }}, "{{ .Name }}", []string{}, "{{ .Name }}")
        {{ else if not .Ignore }}
            //Skipping var {{ .Name }} with unknown data type {{ .DataType }}
            if isMoRef(openapi.{{ .DataType }}{}) {
                cmd.Flags().String("{{ .Name }}", "", "{{ .Name }}")
            }
        {{ end }}
    {{ end }}

    {{ if .Operation }}
        {{ if eq .Operation.HTTPMethod "Get" }}
            {{ if not .Parameter }}
                cmd.Flags().String("filter", "", "Filter query (e.g. \"Name eq 'Bob'\" - note the inner quotes must be single-quotes)")
                cmd.Flags().String("name", "", "Filter by exact name (note: if both --filter and --name are supplied, --name takes precedence")
            {{ end }}
        {{ end }}
    {{ end }}

    return cmd
}{{ end }}

func getQueryParams(flagset *pflag.FlagSet) map[string]string {
    queryParams := map[string]string{}

    if filter, err := flagset.GetString("filter"); err == nil && filter != "" {
        queryParams["filter"] = filter
    }

    if name, err := flagset.GetString("name"); err == nil && name != "" {
        queryParams["name"] = name
    }

    return queryParams
}

func flagSetToMap(flagset *pflag.FlagSet, ret *map[string]interface{}) {
    flagset.Visit(func(f *pflag.Flag) {
        switch f.Value.Type() {
        case "string":
            (*ret)[f.Name], _ = flagset.GetString(f.Name)
        case "bool":
            (*ret)[f.Name], _ = flagset.GetBool(f.Name)
        case "stringSlice":
            (*ret)[f.Name], _ = flagset.GetStringSlice(f.Name)
        default:
            log.Warnf("Unknown type for %s flag", f.Name )
        }
    })

    return
}

func isFlagPassed(flagset *pflag.FlagSet, name string) bool {
    found := false
    flagset.Visit(func(f *pflag.Flag) {
        if f.Name == name {
            found = true
        }
    })
    return found
}

func isMoRef(v interface{}) bool {
    val := reflect.Indirect(reflect.ValueOf(v))
	t := val.Type()
	if t.Kind() != reflect.Struct {
		return false
	}

	_, ok := t.FieldByName("MoMoRef")

	return ok
}

func setMoRefSelector(v interface{}, selector string) bool {
    if !isMoRef(v) {
        return false
    }

    moref := new(openapi.MoMoRef)
    moref.ClassId = "mo.MoRef"
    moref.Selector = &selector

    val := reflect.ValueOf(v).Elem()

    // Here we are trying to find the type of the field other than MoMoRef (e.g. OrganizationOrganization)
    // i.e. the type that this MoRef refers to
    t := val.Type()
    var referredTypeName string
    for i := 0; i < t.NumField(); i++ {
        if t.Field(i).Name == "MoMoRef" {
            continue
        }
        referredTypeName = t.Field(i).Type.Elem().Name()
    }

    moref.ObjectType = goTypeNameToIntersightClassID[referredTypeName]

    val.FieldByName("MoMoRef").Set(reflect.ValueOf(moref))

    return true
}

func runCmd(cmd *cobra.Command, args []string) {
    log.Printf("Running command %s with args %v", cmd.Use, args)
}

// ResultHandler is the function signature to handle API results
type ResultHandler = func(result interface{}, httpResponse *http.Response, err error)

// GetCommands returns the cobra command tree for the API
func GetCommands(client *openapi.APIClient, resultHandler ResultHandler) *cobra.Command {
    rootCmd := {{ template "cliitem" .CliTree }}()
    return rootCmd
}
