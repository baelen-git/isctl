/*
 * Cisco Intersight
 *
 * Cisco Intersight is a management platform delivered as a service with embedded analytics for your Cisco and 3rd party IT infrastructure. This platform offers an intelligent level of management that enables IT organizations to analyze, simplify, and automate their environments in more advanced ways than the prior generations of tools. Cisco Intersight provides an integrated and intuitive management experience for resources in the traditional data center as well as at the edge. With flexible deployment options to address complex security needs, getting started with Intersight is quick and easy. Cisco Intersight has deep integration with Cisco UCS and HyperFlex systems allowing for remote deployment, configuration, and ongoing maintenance. The model-based deployment works for a single system in a remote location or hundreds of systems in a data center and enables rapid, standardized configuration and deployment. It also streamlines maintaining those systems whether you are working with small or very large configurations. The Intersight OpenAPI document defines the complete set of properties that are returned in the HTTP response. From that perspective, a client can expect that no additional properties are returned, unless these properties are explicitly defined in the OpenAPI document. However, when a client uses an older version of the Intersight OpenAPI document, the server may send additional properties because the software is more recent than the client. In that case, the client may receive properties that it does not know about. Some generated SDKs perform a strict validation of the HTTP response body against the OpenAPI document. This document was created on 2021-04-28T13:03:38Z.
 *
 * API version: 1.0.9-4267
 * Contact: intersight@cisco.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SoftwarerepositoryApiService SoftwarerepositoryApi service
type SoftwarerepositoryApiService service

type SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest struct {
	ctx                             _context.Context
	ApiService                      *SoftwarerepositoryApiService
	softwarerepositoryAuthorization *SoftwarerepositoryAuthorization
	ifMatch                         *string
	ifNoneMatch                     *string
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest) SoftwarerepositoryAuthorization(softwarerepositoryAuthorization SoftwarerepositoryAuthorization) SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest {
	r.softwarerepositoryAuthorization = &softwarerepositoryAuthorization
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest) IfNoneMatch(ifNoneMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest) Execute() (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	return r.ApiService.CreateSoftwarerepositoryAuthorizationExecute(r)
}

/*
 * CreateSoftwarerepositoryAuthorization Create a 'softwarerepository.Authorization' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryAuthorization(ctx _context.Context) SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest {
	return SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryAuthorization
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryAuthorizationExecute(r SoftwarerepositoryApiApiCreateSoftwarerepositoryAuthorizationRequest) (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.CreateSoftwarerepositoryAuthorization")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Authorizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryAuthorization == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryAuthorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryAuthorization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest struct {
	ctx                              _context.Context
	ApiService                       *SoftwarerepositoryApiService
	softwarerepositoryCategoryMapper *SoftwarerepositoryCategoryMapper
	ifMatch                          *string
	ifNoneMatch                      *string
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest) SoftwarerepositoryCategoryMapper(softwarerepositoryCategoryMapper SoftwarerepositoryCategoryMapper) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest {
	r.softwarerepositoryCategoryMapper = &softwarerepositoryCategoryMapper
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest) IfNoneMatch(ifNoneMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest) Execute() (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	return r.ApiService.CreateSoftwarerepositoryCategoryMapperExecute(r)
}

/*
 * CreateSoftwarerepositoryCategoryMapper Create a 'softwarerepository.CategoryMapper' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryCategoryMapper(ctx _context.Context) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest {
	return SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapper
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryCategoryMapperExecute(r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperRequest) (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.CreateSoftwarerepositoryCategoryMapper")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMappers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategoryMapper == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategoryMapper is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategoryMapper
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest struct {
	ctx                                   _context.Context
	ApiService                            *SoftwarerepositoryApiService
	softwarerepositoryCategoryMapperModel *SoftwarerepositoryCategoryMapperModel
	ifMatch                               *string
	ifNoneMatch                           *string
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest) SoftwarerepositoryCategoryMapperModel(softwarerepositoryCategoryMapperModel SoftwarerepositoryCategoryMapperModel) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest {
	r.softwarerepositoryCategoryMapperModel = &softwarerepositoryCategoryMapperModel
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest) IfNoneMatch(ifNoneMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest) Execute() (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	return r.ApiService.CreateSoftwarerepositoryCategoryMapperModelExecute(r)
}

/*
 * CreateSoftwarerepositoryCategoryMapperModel Create a 'softwarerepository.CategoryMapperModel' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryCategoryMapperModel(ctx _context.Context) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest {
	return SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapperModel
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryCategoryMapperModelExecute(r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategoryMapperModelRequest) (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapperModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.CreateSoftwarerepositoryCategoryMapperModel")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMapperModels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategoryMapperModel == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategoryMapperModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategoryMapperModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest struct {
	ctx                                         _context.Context
	ApiService                                  *SoftwarerepositoryApiService
	softwarerepositoryCategorySupportConstraint *SoftwarerepositoryCategorySupportConstraint
	ifMatch                                     *string
	ifNoneMatch                                 *string
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest) SoftwarerepositoryCategorySupportConstraint(softwarerepositoryCategorySupportConstraint SoftwarerepositoryCategorySupportConstraint) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest {
	r.softwarerepositoryCategorySupportConstraint = &softwarerepositoryCategorySupportConstraint
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest) IfNoneMatch(ifNoneMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest) Execute() (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	return r.ApiService.CreateSoftwarerepositoryCategorySupportConstraintExecute(r)
}

/*
 * CreateSoftwarerepositoryCategorySupportConstraint Create a 'softwarerepository.CategorySupportConstraint' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryCategorySupportConstraint(ctx _context.Context) SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest {
	return SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategorySupportConstraint
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryCategorySupportConstraintExecute(r SoftwarerepositoryApiApiCreateSoftwarerepositoryCategorySupportConstraintRequest) (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategorySupportConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.CreateSoftwarerepositoryCategorySupportConstraint")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategorySupportConstraints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategorySupportConstraint == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategorySupportConstraint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategorySupportConstraint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest struct {
	ctx                                   _context.Context
	ApiService                            *SoftwarerepositoryApiService
	softwarerepositoryOperatingSystemFile *SoftwarerepositoryOperatingSystemFile
	ifMatch                               *string
	ifNoneMatch                           *string
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest) SoftwarerepositoryOperatingSystemFile(softwarerepositoryOperatingSystemFile SoftwarerepositoryOperatingSystemFile) SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest {
	r.softwarerepositoryOperatingSystemFile = &softwarerepositoryOperatingSystemFile
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest) IfNoneMatch(ifNoneMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest) Execute() (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	return r.ApiService.CreateSoftwarerepositoryOperatingSystemFileExecute(r)
}

/*
 * CreateSoftwarerepositoryOperatingSystemFile Create a 'softwarerepository.OperatingSystemFile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryOperatingSystemFile(ctx _context.Context) SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest {
	return SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryOperatingSystemFile
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryOperatingSystemFileExecute(r SoftwarerepositoryApiApiCreateSoftwarerepositoryOperatingSystemFileRequest) (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryOperatingSystemFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.CreateSoftwarerepositoryOperatingSystemFile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/OperatingSystemFiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryOperatingSystemFile == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryOperatingSystemFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryOperatingSystemFile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest struct {
	ctx                       _context.Context
	ApiService                *SoftwarerepositoryApiService
	softwarerepositoryRelease *SoftwarerepositoryRelease
	ifMatch                   *string
	ifNoneMatch               *string
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest) SoftwarerepositoryRelease(softwarerepositoryRelease SoftwarerepositoryRelease) SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest {
	r.softwarerepositoryRelease = &softwarerepositoryRelease
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest) IfNoneMatch(ifNoneMatch string) SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest) Execute() (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	return r.ApiService.CreateSoftwarerepositoryReleaseExecute(r)
}

/*
 * CreateSoftwarerepositoryRelease Create a 'softwarerepository.Release' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryRelease(ctx _context.Context) SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest {
	return SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryRelease
 */
func (a *SoftwarerepositoryApiService) CreateSoftwarerepositoryReleaseExecute(r SoftwarerepositoryApiApiCreateSoftwarerepositoryReleaseRequest) (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.CreateSoftwarerepositoryRelease")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Releases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryRelease == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryRelease is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSoftwarerepositoryCategoryMapperExecute(r)
}

/*
 * DeleteSoftwarerepositoryCategoryMapper Delete a 'softwarerepository.CategoryMapper' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperRequest
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryCategoryMapper(ctx _context.Context, moid string) SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperRequest {
	return SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryCategoryMapperExecute(r SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.DeleteSoftwarerepositoryCategoryMapper")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMappers/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperModelRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperModelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSoftwarerepositoryCategoryMapperModelExecute(r)
}

/*
 * DeleteSoftwarerepositoryCategoryMapperModel Delete a 'softwarerepository.CategoryMapperModel' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperModelRequest
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryCategoryMapperModel(ctx _context.Context, moid string) SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperModelRequest {
	return SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperModelRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryCategoryMapperModelExecute(r SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategoryMapperModelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.DeleteSoftwarerepositoryCategoryMapperModel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMapperModels/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategorySupportConstraintRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategorySupportConstraintRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSoftwarerepositoryCategorySupportConstraintExecute(r)
}

/*
 * DeleteSoftwarerepositoryCategorySupportConstraint Delete a 'softwarerepository.CategorySupportConstraint' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategorySupportConstraintRequest
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryCategorySupportConstraint(ctx _context.Context, moid string) SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategorySupportConstraintRequest {
	return SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategorySupportConstraintRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryCategorySupportConstraintExecute(r SoftwarerepositoryApiApiDeleteSoftwarerepositoryCategorySupportConstraintRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.DeleteSoftwarerepositoryCategorySupportConstraint")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategorySupportConstraints/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiDeleteSoftwarerepositoryOperatingSystemFileRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiDeleteSoftwarerepositoryOperatingSystemFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSoftwarerepositoryOperatingSystemFileExecute(r)
}

/*
 * DeleteSoftwarerepositoryOperatingSystemFile Delete a 'softwarerepository.OperatingSystemFile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiDeleteSoftwarerepositoryOperatingSystemFileRequest
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryOperatingSystemFile(ctx _context.Context, moid string) SoftwarerepositoryApiApiDeleteSoftwarerepositoryOperatingSystemFileRequest {
	return SoftwarerepositoryApiApiDeleteSoftwarerepositoryOperatingSystemFileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryOperatingSystemFileExecute(r SoftwarerepositoryApiApiDeleteSoftwarerepositoryOperatingSystemFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.DeleteSoftwarerepositoryOperatingSystemFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/OperatingSystemFiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiDeleteSoftwarerepositoryReleaseRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiDeleteSoftwarerepositoryReleaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSoftwarerepositoryReleaseExecute(r)
}

/*
 * DeleteSoftwarerepositoryRelease Delete a 'softwarerepository.Release' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiDeleteSoftwarerepositoryReleaseRequest
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryRelease(ctx _context.Context, moid string) SoftwarerepositoryApiApiDeleteSoftwarerepositoryReleaseRequest {
	return SoftwarerepositoryApiApiDeleteSoftwarerepositoryReleaseRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *SoftwarerepositoryApiService) DeleteSoftwarerepositoryReleaseExecute(r SoftwarerepositoryApiApiDeleteSoftwarerepositoryReleaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.DeleteSoftwarerepositoryRelease")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Releases/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationByMoidRequest) Execute() (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryAuthorizationByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryAuthorizationByMoid Read a 'softwarerepository.Authorization' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryAuthorizationByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryAuthorization
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryAuthorizationByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationByMoidRequest) (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryAuthorizationByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Authorizations/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) Execute() (SoftwarerepositoryAuthorizationResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryAuthorizationListExecute(r)
}

/*
 * GetSoftwarerepositoryAuthorizationList Read a 'softwarerepository.Authorization' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryAuthorizationList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryAuthorizationResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryAuthorizationListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryAuthorizationListRequest) (SoftwarerepositoryAuthorizationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryAuthorizationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryAuthorizationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Authorizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageByMoidRequest) Execute() (SoftwarerepositoryCachedImage, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCachedImageByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryCachedImageByMoid Read a 'softwarerepository.CachedImage' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCachedImageByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCachedImage
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCachedImageByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageByMoidRequest) (SoftwarerepositoryCachedImage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCachedImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCachedImageByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CachedImages/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) Execute() (SoftwarerepositoryCachedImageResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCachedImageListExecute(r)
}

/*
 * GetSoftwarerepositoryCachedImageList Read a 'softwarerepository.CachedImage' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCachedImageList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCachedImageResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCachedImageListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCachedImageListRequest) (SoftwarerepositoryCachedImageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCachedImageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCachedImageList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CachedImages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogByMoidRequest) Execute() (SoftwarerepositoryCatalog, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCatalogByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryCatalogByMoid Read a 'softwarerepository.Catalog' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCatalogByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCatalog
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCatalogByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogByMoidRequest) (SoftwarerepositoryCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCatalogByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Catalogs/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) Execute() (SoftwarerepositoryCatalogResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCatalogListExecute(r)
}

/*
 * GetSoftwarerepositoryCatalogList Read a 'softwarerepository.Catalog' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCatalogList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCatalogResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCatalogListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCatalogListRequest) (SoftwarerepositoryCatalogResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCatalogResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCatalogList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Catalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperByMoidRequest) Execute() (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCategoryMapperByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryCategoryMapperByMoid Read a 'softwarerepository.CategoryMapper' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapper
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperByMoidRequest) (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCategoryMapperByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMappers/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) Execute() (SoftwarerepositoryCategoryMapperResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCategoryMapperListExecute(r)
}

/*
 * GetSoftwarerepositoryCategoryMapperList Read a 'softwarerepository.CategoryMapper' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapperResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperListRequest) (SoftwarerepositoryCategoryMapperResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapperResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCategoryMapperList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMappers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelByMoidRequest) Execute() (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCategoryMapperModelByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryCategoryMapperModelByMoid Read a 'softwarerepository.CategoryMapperModel' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperModelByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapperModel
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperModelByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelByMoidRequest) (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapperModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCategoryMapperModelByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMapperModels/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) Execute() (SoftwarerepositoryCategoryMapperModelResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCategoryMapperModelListExecute(r)
}

/*
 * GetSoftwarerepositoryCategoryMapperModelList Read a 'softwarerepository.CategoryMapperModel' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperModelList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapperModelResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategoryMapperModelListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCategoryMapperModelListRequest) (SoftwarerepositoryCategoryMapperModelResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapperModelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCategoryMapperModelList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMapperModels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintByMoidRequest) Execute() (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCategorySupportConstraintByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryCategorySupportConstraintByMoid Read a 'softwarerepository.CategorySupportConstraint' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategorySupportConstraintByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategorySupportConstraint
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategorySupportConstraintByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintByMoidRequest) (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategorySupportConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCategorySupportConstraintByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategorySupportConstraints/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) Execute() (SoftwarerepositoryCategorySupportConstraintResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryCategorySupportConstraintListExecute(r)
}

/*
 * GetSoftwarerepositoryCategorySupportConstraintList Read a 'softwarerepository.CategorySupportConstraint' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategorySupportConstraintList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategorySupportConstraintResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryCategorySupportConstraintListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryCategorySupportConstraintListRequest) (SoftwarerepositoryCategorySupportConstraintResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategorySupportConstraintResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryCategorySupportConstraintList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategorySupportConstraints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecByMoidRequest) Execute() (SoftwarerepositoryDownloadSpec, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryDownloadSpecByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryDownloadSpecByMoid Read a 'softwarerepository.DownloadSpec' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryDownloadSpecByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryDownloadSpec
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryDownloadSpecByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecByMoidRequest) (SoftwarerepositoryDownloadSpec, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryDownloadSpec
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryDownloadSpecByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/DownloadSpecs/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) Execute() (SoftwarerepositoryDownloadSpecResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryDownloadSpecListExecute(r)
}

/*
 * GetSoftwarerepositoryDownloadSpecList Read a 'softwarerepository.DownloadSpec' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryDownloadSpecList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryDownloadSpecResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryDownloadSpecListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryDownloadSpecListRequest) (SoftwarerepositoryDownloadSpecResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryDownloadSpecResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryDownloadSpecList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/DownloadSpecs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileByMoidRequest) Execute() (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryOperatingSystemFileByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryOperatingSystemFileByMoid Read a 'softwarerepository.OperatingSystemFile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryOperatingSystemFileByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryOperatingSystemFile
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryOperatingSystemFileByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileByMoidRequest) (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryOperatingSystemFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryOperatingSystemFileByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/OperatingSystemFiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) Execute() (SoftwarerepositoryOperatingSystemFileResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryOperatingSystemFileListExecute(r)
}

/*
 * GetSoftwarerepositoryOperatingSystemFileList Read a 'softwarerepository.OperatingSystemFile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryOperatingSystemFileList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryOperatingSystemFileResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryOperatingSystemFileListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryOperatingSystemFileListRequest) (SoftwarerepositoryOperatingSystemFileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryOperatingSystemFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryOperatingSystemFileList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/OperatingSystemFiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseByMoidRequest struct {
	ctx        _context.Context
	ApiService *SoftwarerepositoryApiService
	moid       string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseByMoidRequest) Execute() (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryReleaseByMoidExecute(r)
}

/*
 * GetSoftwarerepositoryReleaseByMoid Read a 'softwarerepository.Release' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseByMoidRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryReleaseByMoid(ctx _context.Context, moid string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseByMoidRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryRelease
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryReleaseByMoidExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseByMoidRequest) (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryReleaseByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Releases/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest struct {
	ctx         _context.Context
	ApiService  *SoftwarerepositoryApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Filter(filter string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.filter = &filter
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Orderby(orderby string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.orderby = &orderby
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Top(top int32) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.top = &top
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Skip(skip int32) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.skip = &skip
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Select_(select_ string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.select_ = &select_
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Expand(expand string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.expand = &expand
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Apply(apply string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.apply = &apply
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Count(count bool) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.count = &count
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Inlinecount(inlinecount string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) At(at string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.at = &at
	return r
}
func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Tags(tags string) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	r.tags = &tags
	return r
}

func (r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) Execute() (SoftwarerepositoryReleaseResponse, *_nethttp.Response, error) {
	return r.ApiService.GetSoftwarerepositoryReleaseListExecute(r)
}

/*
 * GetSoftwarerepositoryReleaseList Read a 'softwarerepository.Release' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryReleaseList(ctx _context.Context) SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest {
	return SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryReleaseResponse
 */
func (a *SoftwarerepositoryApiService) GetSoftwarerepositoryReleaseListExecute(r SoftwarerepositoryApiApiGetSoftwarerepositoryReleaseListRequest) (SoftwarerepositoryReleaseResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryReleaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.GetSoftwarerepositoryReleaseList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Releases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest struct {
	ctx                             _context.Context
	ApiService                      *SoftwarerepositoryApiService
	moid                            string
	softwarerepositoryAuthorization *SoftwarerepositoryAuthorization
	ifMatch                         *string
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest) SoftwarerepositoryAuthorization(softwarerepositoryAuthorization SoftwarerepositoryAuthorization) SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest {
	r.softwarerepositoryAuthorization = &softwarerepositoryAuthorization
	return r
}
func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest) Execute() (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	return r.ApiService.PatchSoftwarerepositoryAuthorizationExecute(r)
}

/*
 * PatchSoftwarerepositoryAuthorization Update a 'softwarerepository.Authorization' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryAuthorization(ctx _context.Context, moid string) SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest {
	return SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryAuthorization
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryAuthorizationExecute(r SoftwarerepositoryApiApiPatchSoftwarerepositoryAuthorizationRequest) (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.PatchSoftwarerepositoryAuthorization")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Authorizations/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryAuthorization == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryAuthorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryAuthorization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest struct {
	ctx                              _context.Context
	ApiService                       *SoftwarerepositoryApiService
	moid                             string
	softwarerepositoryCategoryMapper *SoftwarerepositoryCategoryMapper
	ifMatch                          *string
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest) SoftwarerepositoryCategoryMapper(softwarerepositoryCategoryMapper SoftwarerepositoryCategoryMapper) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest {
	r.softwarerepositoryCategoryMapper = &softwarerepositoryCategoryMapper
	return r
}
func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest) Execute() (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	return r.ApiService.PatchSoftwarerepositoryCategoryMapperExecute(r)
}

/*
 * PatchSoftwarerepositoryCategoryMapper Update a 'softwarerepository.CategoryMapper' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryCategoryMapper(ctx _context.Context, moid string) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest {
	return SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapper
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryCategoryMapperExecute(r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperRequest) (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.PatchSoftwarerepositoryCategoryMapper")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMappers/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategoryMapper == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategoryMapper is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategoryMapper
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest struct {
	ctx                                   _context.Context
	ApiService                            *SoftwarerepositoryApiService
	moid                                  string
	softwarerepositoryCategoryMapperModel *SoftwarerepositoryCategoryMapperModel
	ifMatch                               *string
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest) SoftwarerepositoryCategoryMapperModel(softwarerepositoryCategoryMapperModel SoftwarerepositoryCategoryMapperModel) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest {
	r.softwarerepositoryCategoryMapperModel = &softwarerepositoryCategoryMapperModel
	return r
}
func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest) Execute() (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	return r.ApiService.PatchSoftwarerepositoryCategoryMapperModelExecute(r)
}

/*
 * PatchSoftwarerepositoryCategoryMapperModel Update a 'softwarerepository.CategoryMapperModel' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryCategoryMapperModel(ctx _context.Context, moid string) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest {
	return SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapperModel
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryCategoryMapperModelExecute(r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategoryMapperModelRequest) (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapperModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.PatchSoftwarerepositoryCategoryMapperModel")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMapperModels/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategoryMapperModel == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategoryMapperModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategoryMapperModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest struct {
	ctx                                         _context.Context
	ApiService                                  *SoftwarerepositoryApiService
	moid                                        string
	softwarerepositoryCategorySupportConstraint *SoftwarerepositoryCategorySupportConstraint
	ifMatch                                     *string
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest) SoftwarerepositoryCategorySupportConstraint(softwarerepositoryCategorySupportConstraint SoftwarerepositoryCategorySupportConstraint) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest {
	r.softwarerepositoryCategorySupportConstraint = &softwarerepositoryCategorySupportConstraint
	return r
}
func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest) Execute() (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	return r.ApiService.PatchSoftwarerepositoryCategorySupportConstraintExecute(r)
}

/*
 * PatchSoftwarerepositoryCategorySupportConstraint Update a 'softwarerepository.CategorySupportConstraint' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryCategorySupportConstraint(ctx _context.Context, moid string) SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest {
	return SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategorySupportConstraint
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryCategorySupportConstraintExecute(r SoftwarerepositoryApiApiPatchSoftwarerepositoryCategorySupportConstraintRequest) (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategorySupportConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.PatchSoftwarerepositoryCategorySupportConstraint")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategorySupportConstraints/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategorySupportConstraint == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategorySupportConstraint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategorySupportConstraint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest struct {
	ctx                                   _context.Context
	ApiService                            *SoftwarerepositoryApiService
	moid                                  string
	softwarerepositoryOperatingSystemFile *SoftwarerepositoryOperatingSystemFile
	ifMatch                               *string
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest) SoftwarerepositoryOperatingSystemFile(softwarerepositoryOperatingSystemFile SoftwarerepositoryOperatingSystemFile) SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest {
	r.softwarerepositoryOperatingSystemFile = &softwarerepositoryOperatingSystemFile
	return r
}
func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest) Execute() (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	return r.ApiService.PatchSoftwarerepositoryOperatingSystemFileExecute(r)
}

/*
 * PatchSoftwarerepositoryOperatingSystemFile Update a 'softwarerepository.OperatingSystemFile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryOperatingSystemFile(ctx _context.Context, moid string) SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest {
	return SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryOperatingSystemFile
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryOperatingSystemFileExecute(r SoftwarerepositoryApiApiPatchSoftwarerepositoryOperatingSystemFileRequest) (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryOperatingSystemFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.PatchSoftwarerepositoryOperatingSystemFile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/OperatingSystemFiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryOperatingSystemFile == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryOperatingSystemFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryOperatingSystemFile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest struct {
	ctx                       _context.Context
	ApiService                *SoftwarerepositoryApiService
	moid                      string
	softwarerepositoryRelease *SoftwarerepositoryRelease
	ifMatch                   *string
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest) SoftwarerepositoryRelease(softwarerepositoryRelease SoftwarerepositoryRelease) SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest {
	r.softwarerepositoryRelease = &softwarerepositoryRelease
	return r
}
func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest) Execute() (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	return r.ApiService.PatchSoftwarerepositoryReleaseExecute(r)
}

/*
 * PatchSoftwarerepositoryRelease Update a 'softwarerepository.Release' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryRelease(ctx _context.Context, moid string) SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest {
	return SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryRelease
 */
func (a *SoftwarerepositoryApiService) PatchSoftwarerepositoryReleaseExecute(r SoftwarerepositoryApiApiPatchSoftwarerepositoryReleaseRequest) (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.PatchSoftwarerepositoryRelease")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Releases/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryRelease == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryRelease is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest struct {
	ctx                             _context.Context
	ApiService                      *SoftwarerepositoryApiService
	moid                            string
	softwarerepositoryAuthorization *SoftwarerepositoryAuthorization
	ifMatch                         *string
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest) SoftwarerepositoryAuthorization(softwarerepositoryAuthorization SoftwarerepositoryAuthorization) SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest {
	r.softwarerepositoryAuthorization = &softwarerepositoryAuthorization
	return r
}
func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest) Execute() (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	return r.ApiService.UpdateSoftwarerepositoryAuthorizationExecute(r)
}

/*
 * UpdateSoftwarerepositoryAuthorization Update a 'softwarerepository.Authorization' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryAuthorization(ctx _context.Context, moid string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest {
	return SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryAuthorization
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryAuthorizationExecute(r SoftwarerepositoryApiApiUpdateSoftwarerepositoryAuthorizationRequest) (SoftwarerepositoryAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.UpdateSoftwarerepositoryAuthorization")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Authorizations/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryAuthorization == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryAuthorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryAuthorization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest struct {
	ctx                              _context.Context
	ApiService                       *SoftwarerepositoryApiService
	moid                             string
	softwarerepositoryCategoryMapper *SoftwarerepositoryCategoryMapper
	ifMatch                          *string
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest) SoftwarerepositoryCategoryMapper(softwarerepositoryCategoryMapper SoftwarerepositoryCategoryMapper) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest {
	r.softwarerepositoryCategoryMapper = &softwarerepositoryCategoryMapper
	return r
}
func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest) Execute() (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	return r.ApiService.UpdateSoftwarerepositoryCategoryMapperExecute(r)
}

/*
 * UpdateSoftwarerepositoryCategoryMapper Update a 'softwarerepository.CategoryMapper' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryCategoryMapper(ctx _context.Context, moid string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest {
	return SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapper
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryCategoryMapperExecute(r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperRequest) (SoftwarerepositoryCategoryMapper, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.UpdateSoftwarerepositoryCategoryMapper")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMappers/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategoryMapper == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategoryMapper is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategoryMapper
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest struct {
	ctx                                   _context.Context
	ApiService                            *SoftwarerepositoryApiService
	moid                                  string
	softwarerepositoryCategoryMapperModel *SoftwarerepositoryCategoryMapperModel
	ifMatch                               *string
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest) SoftwarerepositoryCategoryMapperModel(softwarerepositoryCategoryMapperModel SoftwarerepositoryCategoryMapperModel) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest {
	r.softwarerepositoryCategoryMapperModel = &softwarerepositoryCategoryMapperModel
	return r
}
func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest) Execute() (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	return r.ApiService.UpdateSoftwarerepositoryCategoryMapperModelExecute(r)
}

/*
 * UpdateSoftwarerepositoryCategoryMapperModel Update a 'softwarerepository.CategoryMapperModel' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryCategoryMapperModel(ctx _context.Context, moid string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest {
	return SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategoryMapperModel
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryCategoryMapperModelExecute(r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategoryMapperModelRequest) (SoftwarerepositoryCategoryMapperModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategoryMapperModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.UpdateSoftwarerepositoryCategoryMapperModel")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategoryMapperModels/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategoryMapperModel == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategoryMapperModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategoryMapperModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest struct {
	ctx                                         _context.Context
	ApiService                                  *SoftwarerepositoryApiService
	moid                                        string
	softwarerepositoryCategorySupportConstraint *SoftwarerepositoryCategorySupportConstraint
	ifMatch                                     *string
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest) SoftwarerepositoryCategorySupportConstraint(softwarerepositoryCategorySupportConstraint SoftwarerepositoryCategorySupportConstraint) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest {
	r.softwarerepositoryCategorySupportConstraint = &softwarerepositoryCategorySupportConstraint
	return r
}
func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest) Execute() (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	return r.ApiService.UpdateSoftwarerepositoryCategorySupportConstraintExecute(r)
}

/*
 * UpdateSoftwarerepositoryCategorySupportConstraint Update a 'softwarerepository.CategorySupportConstraint' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryCategorySupportConstraint(ctx _context.Context, moid string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest {
	return SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryCategorySupportConstraint
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryCategorySupportConstraintExecute(r SoftwarerepositoryApiApiUpdateSoftwarerepositoryCategorySupportConstraintRequest) (SoftwarerepositoryCategorySupportConstraint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryCategorySupportConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.UpdateSoftwarerepositoryCategorySupportConstraint")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/CategorySupportConstraints/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryCategorySupportConstraint == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryCategorySupportConstraint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryCategorySupportConstraint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest struct {
	ctx                                   _context.Context
	ApiService                            *SoftwarerepositoryApiService
	moid                                  string
	softwarerepositoryOperatingSystemFile *SoftwarerepositoryOperatingSystemFile
	ifMatch                               *string
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest) SoftwarerepositoryOperatingSystemFile(softwarerepositoryOperatingSystemFile SoftwarerepositoryOperatingSystemFile) SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest {
	r.softwarerepositoryOperatingSystemFile = &softwarerepositoryOperatingSystemFile
	return r
}
func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest) Execute() (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	return r.ApiService.UpdateSoftwarerepositoryOperatingSystemFileExecute(r)
}

/*
 * UpdateSoftwarerepositoryOperatingSystemFile Update a 'softwarerepository.OperatingSystemFile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryOperatingSystemFile(ctx _context.Context, moid string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest {
	return SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryOperatingSystemFile
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryOperatingSystemFileExecute(r SoftwarerepositoryApiApiUpdateSoftwarerepositoryOperatingSystemFileRequest) (SoftwarerepositoryOperatingSystemFile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryOperatingSystemFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.UpdateSoftwarerepositoryOperatingSystemFile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/OperatingSystemFiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryOperatingSystemFile == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryOperatingSystemFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryOperatingSystemFile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest struct {
	ctx                       _context.Context
	ApiService                *SoftwarerepositoryApiService
	moid                      string
	softwarerepositoryRelease *SoftwarerepositoryRelease
	ifMatch                   *string
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest) SoftwarerepositoryRelease(softwarerepositoryRelease SoftwarerepositoryRelease) SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest {
	r.softwarerepositoryRelease = &softwarerepositoryRelease
	return r
}
func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest) IfMatch(ifMatch string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest) Execute() (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	return r.ApiService.UpdateSoftwarerepositoryReleaseExecute(r)
}

/*
 * UpdateSoftwarerepositoryRelease Update a 'softwarerepository.Release' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryRelease(ctx _context.Context, moid string) SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest {
	return SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return SoftwarerepositoryRelease
 */
func (a *SoftwarerepositoryApiService) UpdateSoftwarerepositoryReleaseExecute(r SoftwarerepositoryApiApiUpdateSoftwarerepositoryReleaseRequest) (SoftwarerepositoryRelease, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarerepositoryRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SoftwarerepositoryApiService.UpdateSoftwarerepositoryRelease")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/softwarerepository/Releases/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.softwarerepositoryRelease == nil {
		return localVarReturnValue, nil, reportError("softwarerepositoryRelease is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.softwarerepositoryRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
