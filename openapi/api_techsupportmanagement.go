/*
 * Cisco Intersight
 *
 * Cisco Intersight is a management platform delivered as a service with embedded analytics for your Cisco and 3rd party IT infrastructure. This platform offers an intelligent level of management that enables IT organizations to analyze, simplify, and automate their environments in more advanced ways than the prior generations of tools. Cisco Intersight provides an integrated and intuitive management experience for resources in the traditional data center as well as at the edge. With flexible deployment options to address complex security needs, getting started with Intersight is quick and easy. Cisco Intersight has deep integration with Cisco UCS and HyperFlex systems allowing for remote deployment, configuration, and ongoing maintenance. The model-based deployment works for a single system in a remote location or hundreds of systems in a data center and enables rapid, standardized configuration and deployment. It also streamlines maintaining those systems whether you are working with small or very large configurations. The Intersight OpenAPI document defines the complete set of properties that are returned in the HTTP response. From that perspective, a client can expect that no additional properties are returned, unless these properties are explicitly defined in the OpenAPI document. However, when a client uses an older version of the Intersight OpenAPI document, the server may send additional properties because the software is more recent than the client. In that case, the client may receive properties that it does not know about. Some generated SDKs perform a strict validation of the HTTP response body against the OpenAPI document. This document was created on 2021-04-28T13:03:38Z.
 *
 * API version: 1.0.9-4267
 * Contact: intersight@cisco.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// TechsupportmanagementApiService TechsupportmanagementApi service
type TechsupportmanagementApiService service

type TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest struct {
	ctx                                          _context.Context
	ApiService                                   *TechsupportmanagementApiService
	techsupportmanagementCollectionControlPolicy *TechsupportmanagementCollectionControlPolicy
	ifMatch                                      *string
	ifNoneMatch                                  *string
}

func (r TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest) TechsupportmanagementCollectionControlPolicy(techsupportmanagementCollectionControlPolicy TechsupportmanagementCollectionControlPolicy) TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest {
	r.techsupportmanagementCollectionControlPolicy = &techsupportmanagementCollectionControlPolicy
	return r
}
func (r TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest) IfMatch(ifMatch string) TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest) IfNoneMatch(ifNoneMatch string) TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest) Execute() (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateTechsupportmanagementCollectionControlPolicyExecute(r)
}

/*
 * CreateTechsupportmanagementCollectionControlPolicy Create a 'techsupportmanagement.CollectionControlPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest
 */
func (a *TechsupportmanagementApiService) CreateTechsupportmanagementCollectionControlPolicy(ctx _context.Context) TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest {
	return TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementCollectionControlPolicy
 */
func (a *TechsupportmanagementApiService) CreateTechsupportmanagementCollectionControlPolicyExecute(r TechsupportmanagementApiApiCreateTechsupportmanagementCollectionControlPolicyRequest) (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementCollectionControlPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.CreateTechsupportmanagementCollectionControlPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/CollectionControlPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.techsupportmanagementCollectionControlPolicy == nil {
		return localVarReturnValue, nil, reportError("techsupportmanagementCollectionControlPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.techsupportmanagementCollectionControlPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest struct {
	ctx                                    _context.Context
	ApiService                             *TechsupportmanagementApiService
	techsupportmanagementTechSupportBundle *TechsupportmanagementTechSupportBundle
	ifMatch                                *string
	ifNoneMatch                            *string
}

func (r TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest) TechsupportmanagementTechSupportBundle(techsupportmanagementTechSupportBundle TechsupportmanagementTechSupportBundle) TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest {
	r.techsupportmanagementTechSupportBundle = &techsupportmanagementTechSupportBundle
	return r
}
func (r TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest) IfMatch(ifMatch string) TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest) IfNoneMatch(ifNoneMatch string) TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest) Execute() (TechsupportmanagementTechSupportBundle, *_nethttp.Response, error) {
	return r.ApiService.CreateTechsupportmanagementTechSupportBundleExecute(r)
}

/*
 * CreateTechsupportmanagementTechSupportBundle Create a 'techsupportmanagement.TechSupportBundle' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest
 */
func (a *TechsupportmanagementApiService) CreateTechsupportmanagementTechSupportBundle(ctx _context.Context) TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest {
	return TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementTechSupportBundle
 */
func (a *TechsupportmanagementApiService) CreateTechsupportmanagementTechSupportBundleExecute(r TechsupportmanagementApiApiCreateTechsupportmanagementTechSupportBundleRequest) (TechsupportmanagementTechSupportBundle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementTechSupportBundle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.CreateTechsupportmanagementTechSupportBundle")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/TechSupportBundles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.techsupportmanagementTechSupportBundle == nil {
		return localVarReturnValue, nil, reportError("techsupportmanagementTechSupportBundle is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.techsupportmanagementTechSupportBundle
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiDeleteTechsupportmanagementCollectionControlPolicyRequest struct {
	ctx        _context.Context
	ApiService *TechsupportmanagementApiService
	moid       string
}

func (r TechsupportmanagementApiApiDeleteTechsupportmanagementCollectionControlPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTechsupportmanagementCollectionControlPolicyExecute(r)
}

/*
 * DeleteTechsupportmanagementCollectionControlPolicy Delete a 'techsupportmanagement.CollectionControlPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiDeleteTechsupportmanagementCollectionControlPolicyRequest
 */
func (a *TechsupportmanagementApiService) DeleteTechsupportmanagementCollectionControlPolicy(ctx _context.Context, moid string) TechsupportmanagementApiApiDeleteTechsupportmanagementCollectionControlPolicyRequest {
	return TechsupportmanagementApiApiDeleteTechsupportmanagementCollectionControlPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *TechsupportmanagementApiService) DeleteTechsupportmanagementCollectionControlPolicyExecute(r TechsupportmanagementApiApiDeleteTechsupportmanagementCollectionControlPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.DeleteTechsupportmanagementCollectionControlPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/CollectionControlPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiDeleteTechsupportmanagementTechSupportBundleRequest struct {
	ctx        _context.Context
	ApiService *TechsupportmanagementApiService
	moid       string
}

func (r TechsupportmanagementApiApiDeleteTechsupportmanagementTechSupportBundleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTechsupportmanagementTechSupportBundleExecute(r)
}

/*
 * DeleteTechsupportmanagementTechSupportBundle Delete a 'techsupportmanagement.TechSupportBundle' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiDeleteTechsupportmanagementTechSupportBundleRequest
 */
func (a *TechsupportmanagementApiService) DeleteTechsupportmanagementTechSupportBundle(ctx _context.Context, moid string) TechsupportmanagementApiApiDeleteTechsupportmanagementTechSupportBundleRequest {
	return TechsupportmanagementApiApiDeleteTechsupportmanagementTechSupportBundleRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *TechsupportmanagementApiService) DeleteTechsupportmanagementTechSupportBundleExecute(r TechsupportmanagementApiApiDeleteTechsupportmanagementTechSupportBundleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.DeleteTechsupportmanagementTechSupportBundle")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/TechSupportBundles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *TechsupportmanagementApiService
	moid       string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyByMoidRequest) Execute() (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementCollectionControlPolicyByMoidExecute(r)
}

/*
 * GetTechsupportmanagementCollectionControlPolicyByMoid Read a 'techsupportmanagement.CollectionControlPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyByMoidRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementCollectionControlPolicyByMoid(ctx _context.Context, moid string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyByMoidRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementCollectionControlPolicy
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementCollectionControlPolicyByMoidExecute(r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyByMoidRequest) (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementCollectionControlPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementCollectionControlPolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/CollectionControlPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest struct {
	ctx         _context.Context
	ApiService  *TechsupportmanagementApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Filter(filter string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.filter = &filter
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Orderby(orderby string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Top(top int32) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.top = &top
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Skip(skip int32) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.skip = &skip
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Select_(select_ string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.select_ = &select_
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Expand(expand string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.expand = &expand
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Apply(apply string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.apply = &apply
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Count(count bool) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.count = &count
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Inlinecount(inlinecount string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) At(at string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.at = &at
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Tags(tags string) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	r.tags = &tags
	return r
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) Execute() (TechsupportmanagementCollectionControlPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementCollectionControlPolicyListExecute(r)
}

/*
 * GetTechsupportmanagementCollectionControlPolicyList Read a 'techsupportmanagement.CollectionControlPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementCollectionControlPolicyList(ctx _context.Context) TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementCollectionControlPolicyResponse
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementCollectionControlPolicyListExecute(r TechsupportmanagementApiApiGetTechsupportmanagementCollectionControlPolicyListRequest) (TechsupportmanagementCollectionControlPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementCollectionControlPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementCollectionControlPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/CollectionControlPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementDownloadByMoidRequest struct {
	ctx        _context.Context
	ApiService *TechsupportmanagementApiService
	moid       string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadByMoidRequest) Execute() (TechsupportmanagementDownload, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementDownloadByMoidExecute(r)
}

/*
 * GetTechsupportmanagementDownloadByMoid Read a 'techsupportmanagement.Download' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiGetTechsupportmanagementDownloadByMoidRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementDownloadByMoid(ctx _context.Context, moid string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadByMoidRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementDownloadByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementDownload
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementDownloadByMoidExecute(r TechsupportmanagementApiApiGetTechsupportmanagementDownloadByMoidRequest) (TechsupportmanagementDownload, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementDownload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementDownloadByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/Downloads/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest struct {
	ctx         _context.Context
	ApiService  *TechsupportmanagementApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Filter(filter string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.filter = &filter
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Orderby(orderby string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.orderby = &orderby
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Top(top int32) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.top = &top
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Skip(skip int32) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.skip = &skip
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Select_(select_ string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.select_ = &select_
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Expand(expand string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.expand = &expand
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Apply(apply string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.apply = &apply
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Count(count bool) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.count = &count
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Inlinecount(inlinecount string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) At(at string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.at = &at
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Tags(tags string) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	r.tags = &tags
	return r
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) Execute() (TechsupportmanagementDownloadResponse, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementDownloadListExecute(r)
}

/*
 * GetTechsupportmanagementDownloadList Read a 'techsupportmanagement.Download' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementDownloadList(ctx _context.Context) TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementDownloadResponse
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementDownloadListExecute(r TechsupportmanagementApiApiGetTechsupportmanagementDownloadListRequest) (TechsupportmanagementDownloadResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementDownloadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementDownloadList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/Downloads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleByMoidRequest struct {
	ctx        _context.Context
	ApiService *TechsupportmanagementApiService
	moid       string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleByMoidRequest) Execute() (TechsupportmanagementTechSupportBundle, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementTechSupportBundleByMoidExecute(r)
}

/*
 * GetTechsupportmanagementTechSupportBundleByMoid Read a 'techsupportmanagement.TechSupportBundle' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleByMoidRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportBundleByMoid(ctx _context.Context, moid string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleByMoidRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementTechSupportBundle
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportBundleByMoidExecute(r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleByMoidRequest) (TechsupportmanagementTechSupportBundle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementTechSupportBundle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementTechSupportBundleByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/TechSupportBundles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest struct {
	ctx         _context.Context
	ApiService  *TechsupportmanagementApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Filter(filter string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.filter = &filter
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Orderby(orderby string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.orderby = &orderby
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Top(top int32) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.top = &top
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Skip(skip int32) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.skip = &skip
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Select_(select_ string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.select_ = &select_
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Expand(expand string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.expand = &expand
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Apply(apply string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.apply = &apply
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Count(count bool) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.count = &count
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Inlinecount(inlinecount string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) At(at string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.at = &at
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Tags(tags string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	r.tags = &tags
	return r
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) Execute() (TechsupportmanagementTechSupportBundleResponse, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementTechSupportBundleListExecute(r)
}

/*
 * GetTechsupportmanagementTechSupportBundleList Read a 'techsupportmanagement.TechSupportBundle' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportBundleList(ctx _context.Context) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementTechSupportBundleResponse
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportBundleListExecute(r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportBundleListRequest) (TechsupportmanagementTechSupportBundleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementTechSupportBundleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementTechSupportBundleList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/TechSupportBundles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusByMoidRequest struct {
	ctx        _context.Context
	ApiService *TechsupportmanagementApiService
	moid       string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusByMoidRequest) Execute() (TechsupportmanagementTechSupportStatus, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementTechSupportStatusByMoidExecute(r)
}

/*
 * GetTechsupportmanagementTechSupportStatusByMoid Read a 'techsupportmanagement.TechSupportStatus' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusByMoidRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportStatusByMoid(ctx _context.Context, moid string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusByMoidRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementTechSupportStatus
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportStatusByMoidExecute(r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusByMoidRequest) (TechsupportmanagementTechSupportStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementTechSupportStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementTechSupportStatusByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/TechSupportStatuses/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest struct {
	ctx         _context.Context
	ApiService  *TechsupportmanagementApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Filter(filter string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.filter = &filter
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Orderby(orderby string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.orderby = &orderby
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Top(top int32) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.top = &top
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Skip(skip int32) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.skip = &skip
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Select_(select_ string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.select_ = &select_
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Expand(expand string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.expand = &expand
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Apply(apply string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.apply = &apply
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Count(count bool) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.count = &count
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Inlinecount(inlinecount string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) At(at string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.at = &at
	return r
}
func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Tags(tags string) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	r.tags = &tags
	return r
}

func (r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) Execute() (TechsupportmanagementTechSupportStatusResponse, *_nethttp.Response, error) {
	return r.ApiService.GetTechsupportmanagementTechSupportStatusListExecute(r)
}

/*
 * GetTechsupportmanagementTechSupportStatusList Read a 'techsupportmanagement.TechSupportStatus' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportStatusList(ctx _context.Context) TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest {
	return TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementTechSupportStatusResponse
 */
func (a *TechsupportmanagementApiService) GetTechsupportmanagementTechSupportStatusListExecute(r TechsupportmanagementApiApiGetTechsupportmanagementTechSupportStatusListRequest) (TechsupportmanagementTechSupportStatusResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementTechSupportStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.GetTechsupportmanagementTechSupportStatusList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/TechSupportStatuses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest struct {
	ctx                                          _context.Context
	ApiService                                   *TechsupportmanagementApiService
	moid                                         string
	techsupportmanagementCollectionControlPolicy *TechsupportmanagementCollectionControlPolicy
	ifMatch                                      *string
}

func (r TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest) TechsupportmanagementCollectionControlPolicy(techsupportmanagementCollectionControlPolicy TechsupportmanagementCollectionControlPolicy) TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest {
	r.techsupportmanagementCollectionControlPolicy = &techsupportmanagementCollectionControlPolicy
	return r
}
func (r TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest) IfMatch(ifMatch string) TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest) Execute() (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchTechsupportmanagementCollectionControlPolicyExecute(r)
}

/*
 * PatchTechsupportmanagementCollectionControlPolicy Update a 'techsupportmanagement.CollectionControlPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest
 */
func (a *TechsupportmanagementApiService) PatchTechsupportmanagementCollectionControlPolicy(ctx _context.Context, moid string) TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest {
	return TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementCollectionControlPolicy
 */
func (a *TechsupportmanagementApiService) PatchTechsupportmanagementCollectionControlPolicyExecute(r TechsupportmanagementApiApiPatchTechsupportmanagementCollectionControlPolicyRequest) (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementCollectionControlPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.PatchTechsupportmanagementCollectionControlPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/CollectionControlPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.techsupportmanagementCollectionControlPolicy == nil {
		return localVarReturnValue, nil, reportError("techsupportmanagementCollectionControlPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.techsupportmanagementCollectionControlPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest struct {
	ctx                                          _context.Context
	ApiService                                   *TechsupportmanagementApiService
	moid                                         string
	techsupportmanagementCollectionControlPolicy *TechsupportmanagementCollectionControlPolicy
	ifMatch                                      *string
}

func (r TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest) TechsupportmanagementCollectionControlPolicy(techsupportmanagementCollectionControlPolicy TechsupportmanagementCollectionControlPolicy) TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest {
	r.techsupportmanagementCollectionControlPolicy = &techsupportmanagementCollectionControlPolicy
	return r
}
func (r TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest) IfMatch(ifMatch string) TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest) Execute() (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateTechsupportmanagementCollectionControlPolicyExecute(r)
}

/*
 * UpdateTechsupportmanagementCollectionControlPolicy Update a 'techsupportmanagement.CollectionControlPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest
 */
func (a *TechsupportmanagementApiService) UpdateTechsupportmanagementCollectionControlPolicy(ctx _context.Context, moid string) TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest {
	return TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return TechsupportmanagementCollectionControlPolicy
 */
func (a *TechsupportmanagementApiService) UpdateTechsupportmanagementCollectionControlPolicyExecute(r TechsupportmanagementApiApiUpdateTechsupportmanagementCollectionControlPolicyRequest) (TechsupportmanagementCollectionControlPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TechsupportmanagementCollectionControlPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TechsupportmanagementApiService.UpdateTechsupportmanagementCollectionControlPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/techsupportmanagement/CollectionControlPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.techsupportmanagementCollectionControlPolicy == nil {
		return localVarReturnValue, nil, reportError("techsupportmanagementCollectionControlPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.techsupportmanagementCollectionControlPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
