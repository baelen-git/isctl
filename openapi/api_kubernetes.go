/*
 * Cisco Intersight
 *
 * Cisco Intersight is a management platform delivered as a service with embedded analytics for your Cisco and 3rd party IT infrastructure. This platform offers an intelligent level of management that enables IT organizations to analyze, simplify, and automate their environments in more advanced ways than the prior generations of tools. Cisco Intersight provides an integrated and intuitive management experience for resources in the traditional data center as well as at the edge. With flexible deployment options to address complex security needs, getting started with Intersight is quick and easy. Cisco Intersight has deep integration with Cisco UCS and HyperFlex systems allowing for remote deployment, configuration, and ongoing maintenance. The model-based deployment works for a single system in a remote location or hundreds of systems in a data center and enables rapid, standardized configuration and deployment. It also streamlines maintaining those systems whether you are working with small or very large configurations. The Intersight OpenAPI document defines the complete set of properties that are returned in the HTTP response. From that perspective, a client can expect that no additional properties are returned, unless these properties are explicitly defined in the OpenAPI document. However, when a client uses an older version of the Intersight OpenAPI document, the server may send additional properties because the software is more recent than the client. In that case, the client may receive properties that it does not know about. Some generated SDKs perform a strict validation of the HTTP response body against the OpenAPI document. This document was created on 2021-04-28T13:03:38Z.
 *
 * API version: 1.0.9-4267
 * Contact: intersight@cisco.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// KubernetesApiService KubernetesApi service
type KubernetesApiService service

type KubernetesApiApiCreateKubernetesAciCniApicRequest struct {
	ctx                  _context.Context
	ApiService           *KubernetesApiService
	kubernetesAciCniApic *KubernetesAciCniApic
	ifMatch              *string
	ifNoneMatch          *string
}

func (r KubernetesApiApiCreateKubernetesAciCniApicRequest) KubernetesAciCniApic(kubernetesAciCniApic KubernetesAciCniApic) KubernetesApiApiCreateKubernetesAciCniApicRequest {
	r.kubernetesAciCniApic = &kubernetesAciCniApic
	return r
}
func (r KubernetesApiApiCreateKubernetesAciCniApicRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesAciCniApicRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesAciCniApicRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesAciCniApicRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesAciCniApicRequest) Execute() (KubernetesAciCniApic, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesAciCniApicExecute(r)
}

/*
 * CreateKubernetesAciCniApic Create a 'kubernetes.AciCniApic' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesAciCniApicRequest
 */
func (a *KubernetesApiService) CreateKubernetesAciCniApic(ctx _context.Context) KubernetesApiApiCreateKubernetesAciCniApicRequest {
	return KubernetesApiApiCreateKubernetesAciCniApicRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniApic
 */
func (a *KubernetesApiService) CreateKubernetesAciCniApicExecute(r KubernetesApiApiCreateKubernetesAciCniApicRequest) (KubernetesAciCniApic, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniApic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesAciCniApic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniApics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniApic == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniApic is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniApic
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesAciCniProfileRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	kubernetesAciCniProfile *KubernetesAciCniProfile
	ifMatch                 *string
	ifNoneMatch             *string
}

func (r KubernetesApiApiCreateKubernetesAciCniProfileRequest) KubernetesAciCniProfile(kubernetesAciCniProfile KubernetesAciCniProfile) KubernetesApiApiCreateKubernetesAciCniProfileRequest {
	r.kubernetesAciCniProfile = &kubernetesAciCniProfile
	return r
}
func (r KubernetesApiApiCreateKubernetesAciCniProfileRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesAciCniProfileRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesAciCniProfileRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesAciCniProfileRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesAciCniProfileRequest) Execute() (KubernetesAciCniProfile, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesAciCniProfileExecute(r)
}

/*
 * CreateKubernetesAciCniProfile Create a 'kubernetes.AciCniProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesAciCniProfileRequest
 */
func (a *KubernetesApiService) CreateKubernetesAciCniProfile(ctx _context.Context) KubernetesApiApiCreateKubernetesAciCniProfileRequest {
	return KubernetesApiApiCreateKubernetesAciCniProfileRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniProfile
 */
func (a *KubernetesApiService) CreateKubernetesAciCniProfileExecute(r KubernetesApiApiCreateKubernetesAciCniProfileRequest) (KubernetesAciCniProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesAciCniProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest struct {
	ctx                                     _context.Context
	ApiService                              *KubernetesApiService
	kubernetesAciCniTenantClusterAllocation *KubernetesAciCniTenantClusterAllocation
	ifMatch                                 *string
	ifNoneMatch                             *string
}

func (r KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest) KubernetesAciCniTenantClusterAllocation(kubernetesAciCniTenantClusterAllocation KubernetesAciCniTenantClusterAllocation) KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest {
	r.kubernetesAciCniTenantClusterAllocation = &kubernetesAciCniTenantClusterAllocation
	return r
}
func (r KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest) Execute() (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesAciCniTenantClusterAllocationExecute(r)
}

/*
 * CreateKubernetesAciCniTenantClusterAllocation Create a 'kubernetes.AciCniTenantClusterAllocation' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest
 */
func (a *KubernetesApiService) CreateKubernetesAciCniTenantClusterAllocation(ctx _context.Context) KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest {
	return KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniTenantClusterAllocation
 */
func (a *KubernetesApiService) CreateKubernetesAciCniTenantClusterAllocationExecute(r KubernetesApiApiCreateKubernetesAciCniTenantClusterAllocationRequest) (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniTenantClusterAllocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesAciCniTenantClusterAllocation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniTenantClusterAllocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniTenantClusterAllocation == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniTenantClusterAllocation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniTenantClusterAllocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesAddonDefinitionRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	kubernetesAddonDefinition *KubernetesAddonDefinition
	ifMatch                   *string
	ifNoneMatch               *string
}

func (r KubernetesApiApiCreateKubernetesAddonDefinitionRequest) KubernetesAddonDefinition(kubernetesAddonDefinition KubernetesAddonDefinition) KubernetesApiApiCreateKubernetesAddonDefinitionRequest {
	r.kubernetesAddonDefinition = &kubernetesAddonDefinition
	return r
}
func (r KubernetesApiApiCreateKubernetesAddonDefinitionRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesAddonDefinitionRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesAddonDefinitionRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesAddonDefinitionRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesAddonDefinitionRequest) Execute() (KubernetesAddonDefinition, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesAddonDefinitionExecute(r)
}

/*
 * CreateKubernetesAddonDefinition Create a 'kubernetes.AddonDefinition' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesAddonDefinitionRequest
 */
func (a *KubernetesApiService) CreateKubernetesAddonDefinition(ctx _context.Context) KubernetesApiApiCreateKubernetesAddonDefinitionRequest {
	return KubernetesApiApiCreateKubernetesAddonDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonDefinition
 */
func (a *KubernetesApiService) CreateKubernetesAddonDefinitionExecute(r KubernetesApiApiCreateKubernetesAddonDefinitionRequest) (KubernetesAddonDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesAddonDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonDefinitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonDefinition == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesAddonPolicyRequest struct {
	ctx                   _context.Context
	ApiService            *KubernetesApiService
	kubernetesAddonPolicy *KubernetesAddonPolicy
	ifMatch               *string
	ifNoneMatch           *string
}

func (r KubernetesApiApiCreateKubernetesAddonPolicyRequest) KubernetesAddonPolicy(kubernetesAddonPolicy KubernetesAddonPolicy) KubernetesApiApiCreateKubernetesAddonPolicyRequest {
	r.kubernetesAddonPolicy = &kubernetesAddonPolicy
	return r
}
func (r KubernetesApiApiCreateKubernetesAddonPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesAddonPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesAddonPolicyRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesAddonPolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesAddonPolicyRequest) Execute() (KubernetesAddonPolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesAddonPolicyExecute(r)
}

/*
 * CreateKubernetesAddonPolicy Create a 'kubernetes.AddonPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesAddonPolicyRequest
 */
func (a *KubernetesApiService) CreateKubernetesAddonPolicy(ctx _context.Context) KubernetesApiApiCreateKubernetesAddonPolicyRequest {
	return KubernetesApiApiCreateKubernetesAddonPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonPolicy
 */
func (a *KubernetesApiService) CreateKubernetesAddonPolicyExecute(r KubernetesApiApiCreateKubernetesAddonPolicyRequest) (KubernetesAddonPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesAddonPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesAddonRepositoryRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	kubernetesAddonRepository *KubernetesAddonRepository
	ifMatch                   *string
	ifNoneMatch               *string
}

func (r KubernetesApiApiCreateKubernetesAddonRepositoryRequest) KubernetesAddonRepository(kubernetesAddonRepository KubernetesAddonRepository) KubernetesApiApiCreateKubernetesAddonRepositoryRequest {
	r.kubernetesAddonRepository = &kubernetesAddonRepository
	return r
}
func (r KubernetesApiApiCreateKubernetesAddonRepositoryRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesAddonRepositoryRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesAddonRepositoryRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesAddonRepositoryRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesAddonRepositoryRequest) Execute() (KubernetesAddonRepository, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesAddonRepositoryExecute(r)
}

/*
 * CreateKubernetesAddonRepository Create a 'kubernetes.AddonRepository' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesAddonRepositoryRequest
 */
func (a *KubernetesApiService) CreateKubernetesAddonRepository(ctx _context.Context) KubernetesApiApiCreateKubernetesAddonRepositoryRequest {
	return KubernetesApiApiCreateKubernetesAddonRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonRepository
 */
func (a *KubernetesApiService) CreateKubernetesAddonRepositoryExecute(r KubernetesApiApiCreateKubernetesAddonRepositoryRequest) (KubernetesAddonRepository, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesAddonRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonRepositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonRepository == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesClusterRequest struct {
	ctx               _context.Context
	ApiService        *KubernetesApiService
	kubernetesCluster *KubernetesCluster
	ifMatch           *string
	ifNoneMatch       *string
}

func (r KubernetesApiApiCreateKubernetesClusterRequest) KubernetesCluster(kubernetesCluster KubernetesCluster) KubernetesApiApiCreateKubernetesClusterRequest {
	r.kubernetesCluster = &kubernetesCluster
	return r
}
func (r KubernetesApiApiCreateKubernetesClusterRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesClusterRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesClusterRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesClusterRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesClusterRequest) Execute() (KubernetesCluster, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesClusterExecute(r)
}

/*
 * CreateKubernetesCluster Create a 'kubernetes.Cluster' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesClusterRequest
 */
func (a *KubernetesApiService) CreateKubernetesCluster(ctx _context.Context) KubernetesApiApiCreateKubernetesClusterRequest {
	return KubernetesApiApiCreateKubernetesClusterRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesCluster
 */
func (a *KubernetesApiService) CreateKubernetesClusterExecute(r KubernetesApiApiCreateKubernetesClusterRequest) (KubernetesCluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesCluster")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesCluster == nil {
		return localVarReturnValue, nil, reportError("kubernetesCluster is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesCluster
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesClusterAddonProfileRequest struct {
	ctx                           _context.Context
	ApiService                    *KubernetesApiService
	kubernetesClusterAddonProfile *KubernetesClusterAddonProfile
	ifMatch                       *string
	ifNoneMatch                   *string
}

func (r KubernetesApiApiCreateKubernetesClusterAddonProfileRequest) KubernetesClusterAddonProfile(kubernetesClusterAddonProfile KubernetesClusterAddonProfile) KubernetesApiApiCreateKubernetesClusterAddonProfileRequest {
	r.kubernetesClusterAddonProfile = &kubernetesClusterAddonProfile
	return r
}
func (r KubernetesApiApiCreateKubernetesClusterAddonProfileRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesClusterAddonProfileRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesClusterAddonProfileRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesClusterAddonProfileRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesClusterAddonProfileRequest) Execute() (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesClusterAddonProfileExecute(r)
}

/*
 * CreateKubernetesClusterAddonProfile Create a 'kubernetes.ClusterAddonProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesClusterAddonProfileRequest
 */
func (a *KubernetesApiService) CreateKubernetesClusterAddonProfile(ctx _context.Context) KubernetesApiApiCreateKubernetesClusterAddonProfileRequest {
	return KubernetesApiApiCreateKubernetesClusterAddonProfileRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterAddonProfile
 */
func (a *KubernetesApiService) CreateKubernetesClusterAddonProfileExecute(r KubernetesApiApiCreateKubernetesClusterAddonProfileRequest) (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterAddonProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesClusterAddonProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterAddonProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesClusterAddonProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesClusterAddonProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesClusterAddonProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesClusterProfileRequest struct {
	ctx                      _context.Context
	ApiService               *KubernetesApiService
	kubernetesClusterProfile *KubernetesClusterProfile
	ifMatch                  *string
	ifNoneMatch              *string
}

func (r KubernetesApiApiCreateKubernetesClusterProfileRequest) KubernetesClusterProfile(kubernetesClusterProfile KubernetesClusterProfile) KubernetesApiApiCreateKubernetesClusterProfileRequest {
	r.kubernetesClusterProfile = &kubernetesClusterProfile
	return r
}
func (r KubernetesApiApiCreateKubernetesClusterProfileRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesClusterProfileRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesClusterProfileRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesClusterProfileRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesClusterProfileRequest) Execute() (KubernetesClusterProfile, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesClusterProfileExecute(r)
}

/*
 * CreateKubernetesClusterProfile Create a 'kubernetes.ClusterProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesClusterProfileRequest
 */
func (a *KubernetesApiService) CreateKubernetesClusterProfile(ctx _context.Context) KubernetesApiApiCreateKubernetesClusterProfileRequest {
	return KubernetesApiApiCreateKubernetesClusterProfileRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterProfile
 */
func (a *KubernetesApiService) CreateKubernetesClusterProfileExecute(r KubernetesApiApiCreateKubernetesClusterProfileRequest) (KubernetesClusterProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesClusterProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesClusterProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesClusterProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesClusterProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest struct {
	ctx                              _context.Context
	ApiService                       *KubernetesApiService
	kubernetesContainerRuntimePolicy *KubernetesContainerRuntimePolicy
	ifMatch                          *string
	ifNoneMatch                      *string
}

func (r KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest) KubernetesContainerRuntimePolicy(kubernetesContainerRuntimePolicy KubernetesContainerRuntimePolicy) KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest {
	r.kubernetesContainerRuntimePolicy = &kubernetesContainerRuntimePolicy
	return r
}
func (r KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest) Execute() (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesContainerRuntimePolicyExecute(r)
}

/*
 * CreateKubernetesContainerRuntimePolicy Create a 'kubernetes.ContainerRuntimePolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest
 */
func (a *KubernetesApiService) CreateKubernetesContainerRuntimePolicy(ctx _context.Context) KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest {
	return KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesContainerRuntimePolicy
 */
func (a *KubernetesApiService) CreateKubernetesContainerRuntimePolicyExecute(r KubernetesApiApiCreateKubernetesContainerRuntimePolicyRequest) (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesContainerRuntimePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesContainerRuntimePolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ContainerRuntimePolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesContainerRuntimePolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesContainerRuntimePolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesContainerRuntimePolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesNetworkPolicyRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	kubernetesNetworkPolicy *KubernetesNetworkPolicy
	ifMatch                 *string
	ifNoneMatch             *string
}

func (r KubernetesApiApiCreateKubernetesNetworkPolicyRequest) KubernetesNetworkPolicy(kubernetesNetworkPolicy KubernetesNetworkPolicy) KubernetesApiApiCreateKubernetesNetworkPolicyRequest {
	r.kubernetesNetworkPolicy = &kubernetesNetworkPolicy
	return r
}
func (r KubernetesApiApiCreateKubernetesNetworkPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesNetworkPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesNetworkPolicyRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesNetworkPolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesNetworkPolicyRequest) Execute() (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesNetworkPolicyExecute(r)
}

/*
 * CreateKubernetesNetworkPolicy Create a 'kubernetes.NetworkPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesNetworkPolicyRequest
 */
func (a *KubernetesApiService) CreateKubernetesNetworkPolicy(ctx _context.Context) KubernetesApiApiCreateKubernetesNetworkPolicyRequest {
	return KubernetesApiApiCreateKubernetesNetworkPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNetworkPolicy
 */
func (a *KubernetesApiService) CreateKubernetesNetworkPolicyExecute(r KubernetesApiApiCreateKubernetesNetworkPolicyRequest) (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNetworkPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesNetworkPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NetworkPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesNetworkPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesNetworkPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesNetworkPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesNodeGroupProfileRequest struct {
	ctx                        _context.Context
	ApiService                 *KubernetesApiService
	kubernetesNodeGroupProfile *KubernetesNodeGroupProfile
	ifMatch                    *string
	ifNoneMatch                *string
}

func (r KubernetesApiApiCreateKubernetesNodeGroupProfileRequest) KubernetesNodeGroupProfile(kubernetesNodeGroupProfile KubernetesNodeGroupProfile) KubernetesApiApiCreateKubernetesNodeGroupProfileRequest {
	r.kubernetesNodeGroupProfile = &kubernetesNodeGroupProfile
	return r
}
func (r KubernetesApiApiCreateKubernetesNodeGroupProfileRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesNodeGroupProfileRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesNodeGroupProfileRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesNodeGroupProfileRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesNodeGroupProfileRequest) Execute() (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesNodeGroupProfileExecute(r)
}

/*
 * CreateKubernetesNodeGroupProfile Create a 'kubernetes.NodeGroupProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesNodeGroupProfileRequest
 */
func (a *KubernetesApiService) CreateKubernetesNodeGroupProfile(ctx _context.Context) KubernetesApiApiCreateKubernetesNodeGroupProfileRequest {
	return KubernetesApiApiCreateKubernetesNodeGroupProfileRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNodeGroupProfile
 */
func (a *KubernetesApiService) CreateKubernetesNodeGroupProfileExecute(r KubernetesApiApiCreateKubernetesNodeGroupProfileRequest) (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNodeGroupProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesNodeGroupProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NodeGroupProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesNodeGroupProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesNodeGroupProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesNodeGroupProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesSysConfigPolicyRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	kubernetesSysConfigPolicy *KubernetesSysConfigPolicy
	ifMatch                   *string
	ifNoneMatch               *string
}

func (r KubernetesApiApiCreateKubernetesSysConfigPolicyRequest) KubernetesSysConfigPolicy(kubernetesSysConfigPolicy KubernetesSysConfigPolicy) KubernetesApiApiCreateKubernetesSysConfigPolicyRequest {
	r.kubernetesSysConfigPolicy = &kubernetesSysConfigPolicy
	return r
}
func (r KubernetesApiApiCreateKubernetesSysConfigPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesSysConfigPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesSysConfigPolicyRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesSysConfigPolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesSysConfigPolicyRequest) Execute() (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesSysConfigPolicyExecute(r)
}

/*
 * CreateKubernetesSysConfigPolicy Create a 'kubernetes.SysConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesSysConfigPolicyRequest
 */
func (a *KubernetesApiService) CreateKubernetesSysConfigPolicy(ctx _context.Context) KubernetesApiApiCreateKubernetesSysConfigPolicyRequest {
	return KubernetesApiApiCreateKubernetesSysConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesSysConfigPolicy
 */
func (a *KubernetesApiService) CreateKubernetesSysConfigPolicyExecute(r KubernetesApiApiCreateKubernetesSysConfigPolicyRequest) (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesSysConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesSysConfigPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/SysConfigPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesSysConfigPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesSysConfigPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesSysConfigPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest struct {
	ctx                               _context.Context
	ApiService                        *KubernetesApiService
	kubernetesTrustedRegistriesPolicy *KubernetesTrustedRegistriesPolicy
	ifMatch                           *string
	ifNoneMatch                       *string
}

func (r KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest) KubernetesTrustedRegistriesPolicy(kubernetesTrustedRegistriesPolicy KubernetesTrustedRegistriesPolicy) KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest {
	r.kubernetesTrustedRegistriesPolicy = &kubernetesTrustedRegistriesPolicy
	return r
}
func (r KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest) Execute() (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesTrustedRegistriesPolicyExecute(r)
}

/*
 * CreateKubernetesTrustedRegistriesPolicy Create a 'kubernetes.TrustedRegistriesPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest
 */
func (a *KubernetesApiService) CreateKubernetesTrustedRegistriesPolicy(ctx _context.Context) KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest {
	return KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesTrustedRegistriesPolicy
 */
func (a *KubernetesApiService) CreateKubernetesTrustedRegistriesPolicyExecute(r KubernetesApiApiCreateKubernetesTrustedRegistriesPolicyRequest) (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesTrustedRegistriesPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesTrustedRegistriesPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/TrustedRegistriesPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesTrustedRegistriesPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesTrustedRegistriesPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesTrustedRegistriesPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesVersionRequest struct {
	ctx               _context.Context
	ApiService        *KubernetesApiService
	kubernetesVersion *KubernetesVersion
	ifMatch           *string
	ifNoneMatch       *string
}

func (r KubernetesApiApiCreateKubernetesVersionRequest) KubernetesVersion(kubernetesVersion KubernetesVersion) KubernetesApiApiCreateKubernetesVersionRequest {
	r.kubernetesVersion = &kubernetesVersion
	return r
}
func (r KubernetesApiApiCreateKubernetesVersionRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesVersionRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesVersionRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesVersionRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesVersionRequest) Execute() (KubernetesVersion, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesVersionExecute(r)
}

/*
 * CreateKubernetesVersion Create a 'kubernetes.Version' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesVersionRequest
 */
func (a *KubernetesApiService) CreateKubernetesVersion(ctx _context.Context) KubernetesApiApiCreateKubernetesVersionRequest {
	return KubernetesApiApiCreateKubernetesVersionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersion
 */
func (a *KubernetesApiService) CreateKubernetesVersionExecute(r KubernetesApiApiCreateKubernetesVersionRequest) (KubernetesVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Versions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVersion == nil {
		return localVarReturnValue, nil, reportError("kubernetesVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesVersionPolicyRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	kubernetesVersionPolicy *KubernetesVersionPolicy
	ifMatch                 *string
	ifNoneMatch             *string
}

func (r KubernetesApiApiCreateKubernetesVersionPolicyRequest) KubernetesVersionPolicy(kubernetesVersionPolicy KubernetesVersionPolicy) KubernetesApiApiCreateKubernetesVersionPolicyRequest {
	r.kubernetesVersionPolicy = &kubernetesVersionPolicy
	return r
}
func (r KubernetesApiApiCreateKubernetesVersionPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesVersionPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesVersionPolicyRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesVersionPolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesVersionPolicyRequest) Execute() (KubernetesVersionPolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesVersionPolicyExecute(r)
}

/*
 * CreateKubernetesVersionPolicy Create a 'kubernetes.VersionPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesVersionPolicyRequest
 */
func (a *KubernetesApiService) CreateKubernetesVersionPolicy(ctx _context.Context) KubernetesApiApiCreateKubernetesVersionPolicyRequest {
	return KubernetesApiApiCreateKubernetesVersionPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersionPolicy
 */
func (a *KubernetesApiService) CreateKubernetesVersionPolicyExecute(r KubernetesApiApiCreateKubernetesVersionPolicyRequest) (KubernetesVersionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesVersionPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VersionPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVersionPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesVersionPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVersionPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest struct {
	ctx                                       _context.Context
	ApiService                                *KubernetesApiService
	kubernetesVirtualMachineInfraConfigPolicy *KubernetesVirtualMachineInfraConfigPolicy
	ifMatch                                   *string
	ifNoneMatch                               *string
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest) KubernetesVirtualMachineInfraConfigPolicy(kubernetesVirtualMachineInfraConfigPolicy KubernetesVirtualMachineInfraConfigPolicy) KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest {
	r.kubernetesVirtualMachineInfraConfigPolicy = &kubernetesVirtualMachineInfraConfigPolicy
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest) Execute() (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesVirtualMachineInfraConfigPolicyExecute(r)
}

/*
 * CreateKubernetesVirtualMachineInfraConfigPolicy Create a 'kubernetes.VirtualMachineInfraConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineInfraConfigPolicy(ctx _context.Context) KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest {
	return KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfraConfigPolicy
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineInfraConfigPolicyExecute(r KubernetesApiApiCreateKubernetesVirtualMachineInfraConfigPolicyRequest) (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfraConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesVirtualMachineInfraConfigPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfraConfigPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInfraConfigPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInfraConfigPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInfraConfigPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest struct {
	ctx                                            _context.Context
	ApiService                                     *KubernetesApiService
	kubernetesVirtualMachineInfrastructureProvider *KubernetesVirtualMachineInfrastructureProvider
	ifMatch                                        *string
	ifNoneMatch                                    *string
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest) KubernetesVirtualMachineInfrastructureProvider(kubernetesVirtualMachineInfrastructureProvider KubernetesVirtualMachineInfrastructureProvider) KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest {
	r.kubernetesVirtualMachineInfrastructureProvider = &kubernetesVirtualMachineInfrastructureProvider
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest) Execute() (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesVirtualMachineInfrastructureProviderExecute(r)
}

/*
 * CreateKubernetesVirtualMachineInfrastructureProvider Create a 'kubernetes.VirtualMachineInfrastructureProvider' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineInfrastructureProvider(ctx _context.Context) KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest {
	return KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfrastructureProvider
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineInfrastructureProviderExecute(r KubernetesApiApiCreateKubernetesVirtualMachineInfrastructureProviderRequest) (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfrastructureProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesVirtualMachineInfrastructureProvider")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfrastructureProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInfrastructureProvider == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInfrastructureProvider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInfrastructureProvider
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest struct {
	ctx                                  _context.Context
	ApiService                           *KubernetesApiService
	kubernetesVirtualMachineInstanceType *KubernetesVirtualMachineInstanceType
	ifMatch                              *string
	ifNoneMatch                          *string
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest) KubernetesVirtualMachineInstanceType(kubernetesVirtualMachineInstanceType KubernetesVirtualMachineInstanceType) KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest {
	r.kubernetesVirtualMachineInstanceType = &kubernetesVirtualMachineInstanceType
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest) Execute() (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesVirtualMachineInstanceTypeExecute(r)
}

/*
 * CreateKubernetesVirtualMachineInstanceType Create a 'kubernetes.VirtualMachineInstanceType' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineInstanceType(ctx _context.Context) KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest {
	return KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInstanceType
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineInstanceTypeExecute(r KubernetesApiApiCreateKubernetesVirtualMachineInstanceTypeRequest) (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesVirtualMachineInstanceType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInstanceTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInstanceType == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInstanceType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInstanceType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest struct {
	ctx                                 _context.Context
	ApiService                          *KubernetesApiService
	kubernetesVirtualMachineNodeProfile *KubernetesVirtualMachineNodeProfile
	ifMatch                             *string
	ifNoneMatch                         *string
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest) KubernetesVirtualMachineNodeProfile(kubernetesVirtualMachineNodeProfile KubernetesVirtualMachineNodeProfile) KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest {
	r.kubernetesVirtualMachineNodeProfile = &kubernetesVirtualMachineNodeProfile
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest) IfMatch(ifMatch string) KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest {
	r.ifMatch = &ifMatch
	return r
}
func (r KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest) IfNoneMatch(ifNoneMatch string) KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

func (r KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest) Execute() (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	return r.ApiService.CreateKubernetesVirtualMachineNodeProfileExecute(r)
}

/*
 * CreateKubernetesVirtualMachineNodeProfile Create a 'kubernetes.VirtualMachineNodeProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineNodeProfile(ctx _context.Context) KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest {
	return KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineNodeProfile
 */
func (a *KubernetesApiService) CreateKubernetesVirtualMachineNodeProfileExecute(r KubernetesApiApiCreateKubernetesVirtualMachineNodeProfileRequest) (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineNodeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.CreateKubernetesVirtualMachineNodeProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineNodeProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineNodeProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineNodeProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	if r.ifNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = parameterToString(*r.ifNoneMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineNodeProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesAciCniApicRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesAciCniApicRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesAciCniApicExecute(r)
}

/*
 * DeleteKubernetesAciCniApic Delete a 'kubernetes.AciCniApic' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesAciCniApicRequest
 */
func (a *KubernetesApiService) DeleteKubernetesAciCniApic(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesAciCniApicRequest {
	return KubernetesApiApiDeleteKubernetesAciCniApicRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesAciCniApicExecute(r KubernetesApiApiDeleteKubernetesAciCniApicRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesAciCniApic")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniApics/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesAciCniProfileRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesAciCniProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesAciCniProfileExecute(r)
}

/*
 * DeleteKubernetesAciCniProfile Delete a 'kubernetes.AciCniProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesAciCniProfileRequest
 */
func (a *KubernetesApiService) DeleteKubernetesAciCniProfile(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesAciCniProfileRequest {
	return KubernetesApiApiDeleteKubernetesAciCniProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesAciCniProfileExecute(r KubernetesApiApiDeleteKubernetesAciCniProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesAciCniProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesAciCniTenantClusterAllocationRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesAciCniTenantClusterAllocationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesAciCniTenantClusterAllocationExecute(r)
}

/*
 * DeleteKubernetesAciCniTenantClusterAllocation Delete a 'kubernetes.AciCniTenantClusterAllocation' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesAciCniTenantClusterAllocationRequest
 */
func (a *KubernetesApiService) DeleteKubernetesAciCniTenantClusterAllocation(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesAciCniTenantClusterAllocationRequest {
	return KubernetesApiApiDeleteKubernetesAciCniTenantClusterAllocationRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesAciCniTenantClusterAllocationExecute(r KubernetesApiApiDeleteKubernetesAciCniTenantClusterAllocationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesAciCniTenantClusterAllocation")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniTenantClusterAllocations/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesAddonDefinitionRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesAddonDefinitionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesAddonDefinitionExecute(r)
}

/*
 * DeleteKubernetesAddonDefinition Delete a 'kubernetes.AddonDefinition' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesAddonDefinitionRequest
 */
func (a *KubernetesApiService) DeleteKubernetesAddonDefinition(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesAddonDefinitionRequest {
	return KubernetesApiApiDeleteKubernetesAddonDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesAddonDefinitionExecute(r KubernetesApiApiDeleteKubernetesAddonDefinitionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesAddonDefinition")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonDefinitions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesAddonPolicyRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesAddonPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesAddonPolicyExecute(r)
}

/*
 * DeleteKubernetesAddonPolicy Delete a 'kubernetes.AddonPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesAddonPolicyRequest
 */
func (a *KubernetesApiService) DeleteKubernetesAddonPolicy(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesAddonPolicyRequest {
	return KubernetesApiApiDeleteKubernetesAddonPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesAddonPolicyExecute(r KubernetesApiApiDeleteKubernetesAddonPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesAddonPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesAddonRepositoryRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesAddonRepositoryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesAddonRepositoryExecute(r)
}

/*
 * DeleteKubernetesAddonRepository Delete a 'kubernetes.AddonRepository' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesAddonRepositoryRequest
 */
func (a *KubernetesApiService) DeleteKubernetesAddonRepository(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesAddonRepositoryRequest {
	return KubernetesApiApiDeleteKubernetesAddonRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesAddonRepositoryExecute(r KubernetesApiApiDeleteKubernetesAddonRepositoryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesAddonRepository")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonRepositories/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesClusterRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesClusterRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesClusterExecute(r)
}

/*
 * DeleteKubernetesCluster Delete a 'kubernetes.Cluster' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesClusterRequest
 */
func (a *KubernetesApiService) DeleteKubernetesCluster(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesClusterRequest {
	return KubernetesApiApiDeleteKubernetesClusterRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesClusterExecute(r KubernetesApiApiDeleteKubernetesClusterRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesCluster")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Clusters/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesClusterAddonProfileRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesClusterAddonProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesClusterAddonProfileExecute(r)
}

/*
 * DeleteKubernetesClusterAddonProfile Delete a 'kubernetes.ClusterAddonProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesClusterAddonProfileRequest
 */
func (a *KubernetesApiService) DeleteKubernetesClusterAddonProfile(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesClusterAddonProfileRequest {
	return KubernetesApiApiDeleteKubernetesClusterAddonProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesClusterAddonProfileExecute(r KubernetesApiApiDeleteKubernetesClusterAddonProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesClusterAddonProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterAddonProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesClusterProfileRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesClusterProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesClusterProfileExecute(r)
}

/*
 * DeleteKubernetesClusterProfile Delete a 'kubernetes.ClusterProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesClusterProfileRequest
 */
func (a *KubernetesApiService) DeleteKubernetesClusterProfile(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesClusterProfileRequest {
	return KubernetesApiApiDeleteKubernetesClusterProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesClusterProfileExecute(r KubernetesApiApiDeleteKubernetesClusterProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesClusterProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesContainerRuntimePolicyRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesContainerRuntimePolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesContainerRuntimePolicyExecute(r)
}

/*
 * DeleteKubernetesContainerRuntimePolicy Delete a 'kubernetes.ContainerRuntimePolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesContainerRuntimePolicyRequest
 */
func (a *KubernetesApiService) DeleteKubernetesContainerRuntimePolicy(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesContainerRuntimePolicyRequest {
	return KubernetesApiApiDeleteKubernetesContainerRuntimePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesContainerRuntimePolicyExecute(r KubernetesApiApiDeleteKubernetesContainerRuntimePolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesContainerRuntimePolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ContainerRuntimePolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesDaemonSetRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesDaemonSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesDaemonSetExecute(r)
}

/*
 * DeleteKubernetesDaemonSet Delete a 'kubernetes.DaemonSet' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesDaemonSetRequest
 */
func (a *KubernetesApiService) DeleteKubernetesDaemonSet(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesDaemonSetRequest {
	return KubernetesApiApiDeleteKubernetesDaemonSetRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesDaemonSetExecute(r KubernetesApiApiDeleteKubernetesDaemonSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesDaemonSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/DaemonSets/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesDeploymentRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesDeploymentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesDeploymentExecute(r)
}

/*
 * DeleteKubernetesDeployment Delete a 'kubernetes.Deployment' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesDeploymentRequest
 */
func (a *KubernetesApiService) DeleteKubernetesDeployment(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesDeploymentRequest {
	return KubernetesApiApiDeleteKubernetesDeploymentRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesDeploymentExecute(r KubernetesApiApiDeleteKubernetesDeploymentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesDeployment")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Deployments/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesIngressRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesIngressRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesIngressExecute(r)
}

/*
 * DeleteKubernetesIngress Delete a 'kubernetes.Ingress' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesIngressRequest
 */
func (a *KubernetesApiService) DeleteKubernetesIngress(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesIngressRequest {
	return KubernetesApiApiDeleteKubernetesIngressRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesIngressExecute(r KubernetesApiApiDeleteKubernetesIngressRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesIngress")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Ingresses/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesNetworkPolicyRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesNetworkPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesNetworkPolicyExecute(r)
}

/*
 * DeleteKubernetesNetworkPolicy Delete a 'kubernetes.NetworkPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesNetworkPolicyRequest
 */
func (a *KubernetesApiService) DeleteKubernetesNetworkPolicy(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesNetworkPolicyRequest {
	return KubernetesApiApiDeleteKubernetesNetworkPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesNetworkPolicyExecute(r KubernetesApiApiDeleteKubernetesNetworkPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesNetworkPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NetworkPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesNodeRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesNodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesNodeExecute(r)
}

/*
 * DeleteKubernetesNode Delete a 'kubernetes.Node' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesNodeRequest
 */
func (a *KubernetesApiService) DeleteKubernetesNode(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesNodeRequest {
	return KubernetesApiApiDeleteKubernetesNodeRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesNodeExecute(r KubernetesApiApiDeleteKubernetesNodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesNode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Nodes/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesNodeGroupProfileRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesNodeGroupProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesNodeGroupProfileExecute(r)
}

/*
 * DeleteKubernetesNodeGroupProfile Delete a 'kubernetes.NodeGroupProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesNodeGroupProfileRequest
 */
func (a *KubernetesApiService) DeleteKubernetesNodeGroupProfile(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesNodeGroupProfileRequest {
	return KubernetesApiApiDeleteKubernetesNodeGroupProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesNodeGroupProfileExecute(r KubernetesApiApiDeleteKubernetesNodeGroupProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesNodeGroupProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NodeGroupProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesPodRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesPodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesPodExecute(r)
}

/*
 * DeleteKubernetesPod Delete a 'kubernetes.Pod' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesPodRequest
 */
func (a *KubernetesApiService) DeleteKubernetesPod(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesPodRequest {
	return KubernetesApiApiDeleteKubernetesPodRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesPodExecute(r KubernetesApiApiDeleteKubernetesPodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesPod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Pods/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesServiceRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesServiceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesServiceExecute(r)
}

/*
 * DeleteKubernetesService Delete a 'kubernetes.Service' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesServiceRequest
 */
func (a *KubernetesApiService) DeleteKubernetesService(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesServiceRequest {
	return KubernetesApiApiDeleteKubernetesServiceRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesServiceExecute(r KubernetesApiApiDeleteKubernetesServiceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesService")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Services/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesStatefulSetRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesStatefulSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesStatefulSetExecute(r)
}

/*
 * DeleteKubernetesStatefulSet Delete a 'kubernetes.StatefulSet' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesStatefulSetRequest
 */
func (a *KubernetesApiService) DeleteKubernetesStatefulSet(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesStatefulSetRequest {
	return KubernetesApiApiDeleteKubernetesStatefulSetRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesStatefulSetExecute(r KubernetesApiApiDeleteKubernetesStatefulSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesStatefulSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/StatefulSets/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesSysConfigPolicyRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesSysConfigPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesSysConfigPolicyExecute(r)
}

/*
 * DeleteKubernetesSysConfigPolicy Delete a 'kubernetes.SysConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesSysConfigPolicyRequest
 */
func (a *KubernetesApiService) DeleteKubernetesSysConfigPolicy(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesSysConfigPolicyRequest {
	return KubernetesApiApiDeleteKubernetesSysConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesSysConfigPolicyExecute(r KubernetesApiApiDeleteKubernetesSysConfigPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesSysConfigPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/SysConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesTrustedRegistriesPolicyRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesTrustedRegistriesPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesTrustedRegistriesPolicyExecute(r)
}

/*
 * DeleteKubernetesTrustedRegistriesPolicy Delete a 'kubernetes.TrustedRegistriesPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesTrustedRegistriesPolicyRequest
 */
func (a *KubernetesApiService) DeleteKubernetesTrustedRegistriesPolicy(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesTrustedRegistriesPolicyRequest {
	return KubernetesApiApiDeleteKubernetesTrustedRegistriesPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesTrustedRegistriesPolicyExecute(r KubernetesApiApiDeleteKubernetesTrustedRegistriesPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesTrustedRegistriesPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/TrustedRegistriesPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesVersionRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesVersionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesVersionExecute(r)
}

/*
 * DeleteKubernetesVersion Delete a 'kubernetes.Version' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesVersionRequest
 */
func (a *KubernetesApiService) DeleteKubernetesVersion(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesVersionRequest {
	return KubernetesApiApiDeleteKubernetesVersionRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesVersionExecute(r KubernetesApiApiDeleteKubernetesVersionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesVersion")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Versions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesVersionPolicyRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesVersionPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesVersionPolicyExecute(r)
}

/*
 * DeleteKubernetesVersionPolicy Delete a 'kubernetes.VersionPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesVersionPolicyRequest
 */
func (a *KubernetesApiService) DeleteKubernetesVersionPolicy(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesVersionPolicyRequest {
	return KubernetesApiApiDeleteKubernetesVersionPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesVersionPolicyExecute(r KubernetesApiApiDeleteKubernetesVersionPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesVersionPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VersionPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesVirtualMachineInfraConfigPolicyRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesVirtualMachineInfraConfigPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesVirtualMachineInfraConfigPolicyExecute(r)
}

/*
 * DeleteKubernetesVirtualMachineInfraConfigPolicy Delete a 'kubernetes.VirtualMachineInfraConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesVirtualMachineInfraConfigPolicyRequest
 */
func (a *KubernetesApiService) DeleteKubernetesVirtualMachineInfraConfigPolicy(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesVirtualMachineInfraConfigPolicyRequest {
	return KubernetesApiApiDeleteKubernetesVirtualMachineInfraConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesVirtualMachineInfraConfigPolicyExecute(r KubernetesApiApiDeleteKubernetesVirtualMachineInfraConfigPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesVirtualMachineInfraConfigPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfraConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesVirtualMachineInstanceTypeRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesVirtualMachineInstanceTypeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesVirtualMachineInstanceTypeExecute(r)
}

/*
 * DeleteKubernetesVirtualMachineInstanceType Delete a 'kubernetes.VirtualMachineInstanceType' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesVirtualMachineInstanceTypeRequest
 */
func (a *KubernetesApiService) DeleteKubernetesVirtualMachineInstanceType(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesVirtualMachineInstanceTypeRequest {
	return KubernetesApiApiDeleteKubernetesVirtualMachineInstanceTypeRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesVirtualMachineInstanceTypeExecute(r KubernetesApiApiDeleteKubernetesVirtualMachineInstanceTypeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesVirtualMachineInstanceType")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInstanceTypes/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiDeleteKubernetesVirtualMachineNodeProfileRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiDeleteKubernetesVirtualMachineNodeProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteKubernetesVirtualMachineNodeProfileExecute(r)
}

/*
 * DeleteKubernetesVirtualMachineNodeProfile Delete a 'kubernetes.VirtualMachineNodeProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiDeleteKubernetesVirtualMachineNodeProfileRequest
 */
func (a *KubernetesApiService) DeleteKubernetesVirtualMachineNodeProfile(ctx _context.Context, moid string) KubernetesApiApiDeleteKubernetesVirtualMachineNodeProfileRequest {
	return KubernetesApiApiDeleteKubernetesVirtualMachineNodeProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 */
func (a *KubernetesApiService) DeleteKubernetesVirtualMachineNodeProfileExecute(r KubernetesApiApiDeleteKubernetesVirtualMachineNodeProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.DeleteKubernetesVirtualMachineNodeProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineNodeProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAciCniApicByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesAciCniApicByMoidRequest) Execute() (KubernetesAciCniApic, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAciCniApicByMoidExecute(r)
}

/*
 * GetKubernetesAciCniApicByMoid Read a 'kubernetes.AciCniApic' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesAciCniApicByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesAciCniApicByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesAciCniApicByMoidRequest {
	return KubernetesApiApiGetKubernetesAciCniApicByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniApic
 */
func (a *KubernetesApiService) GetKubernetesAciCniApicByMoidExecute(r KubernetesApiApiGetKubernetesAciCniApicByMoidRequest) (KubernetesAciCniApic, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniApic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAciCniApicByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniApics/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAciCniApicListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Filter(filter string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Top(top int32) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Expand(expand string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Apply(apply string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Count(count bool) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) At(at string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Tags(tags string) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesAciCniApicListRequest) Execute() (KubernetesAciCniApicResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAciCniApicListExecute(r)
}

/*
 * GetKubernetesAciCniApicList Read a 'kubernetes.AciCniApic' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesAciCniApicListRequest
 */
func (a *KubernetesApiService) GetKubernetesAciCniApicList(ctx _context.Context) KubernetesApiApiGetKubernetesAciCniApicListRequest {
	return KubernetesApiApiGetKubernetesAciCniApicListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniApicResponse
 */
func (a *KubernetesApiService) GetKubernetesAciCniApicListExecute(r KubernetesApiApiGetKubernetesAciCniApicListRequest) (KubernetesAciCniApicResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniApicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAciCniApicList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniApics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAciCniProfileByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesAciCniProfileByMoidRequest) Execute() (KubernetesAciCniProfile, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAciCniProfileByMoidExecute(r)
}

/*
 * GetKubernetesAciCniProfileByMoid Read a 'kubernetes.AciCniProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesAciCniProfileByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesAciCniProfileByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesAciCniProfileByMoidRequest {
	return KubernetesApiApiGetKubernetesAciCniProfileByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniProfile
 */
func (a *KubernetesApiService) GetKubernetesAciCniProfileByMoidExecute(r KubernetesApiApiGetKubernetesAciCniProfileByMoidRequest) (KubernetesAciCniProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAciCniProfileByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAciCniProfileListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Filter(filter string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Top(top int32) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Expand(expand string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Apply(apply string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Count(count bool) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) At(at string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Tags(tags string) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesAciCniProfileListRequest) Execute() (KubernetesAciCniProfileResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAciCniProfileListExecute(r)
}

/*
 * GetKubernetesAciCniProfileList Read a 'kubernetes.AciCniProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesAciCniProfileListRequest
 */
func (a *KubernetesApiService) GetKubernetesAciCniProfileList(ctx _context.Context) KubernetesApiApiGetKubernetesAciCniProfileListRequest {
	return KubernetesApiApiGetKubernetesAciCniProfileListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniProfileResponse
 */
func (a *KubernetesApiService) GetKubernetesAciCniProfileListExecute(r KubernetesApiApiGetKubernetesAciCniProfileListRequest) (KubernetesAciCniProfileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAciCniProfileList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationByMoidRequest) Execute() (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAciCniTenantClusterAllocationByMoidExecute(r)
}

/*
 * GetKubernetesAciCniTenantClusterAllocationByMoid Read a 'kubernetes.AciCniTenantClusterAllocation' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesAciCniTenantClusterAllocationByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationByMoidRequest {
	return KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniTenantClusterAllocation
 */
func (a *KubernetesApiService) GetKubernetesAciCniTenantClusterAllocationByMoidExecute(r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationByMoidRequest) (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniTenantClusterAllocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAciCniTenantClusterAllocationByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniTenantClusterAllocations/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Filter(filter string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Top(top int32) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Expand(expand string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Apply(apply string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Count(count bool) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) At(at string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Tags(tags string) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) Execute() (KubernetesAciCniTenantClusterAllocationResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAciCniTenantClusterAllocationListExecute(r)
}

/*
 * GetKubernetesAciCniTenantClusterAllocationList Read a 'kubernetes.AciCniTenantClusterAllocation' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest
 */
func (a *KubernetesApiService) GetKubernetesAciCniTenantClusterAllocationList(ctx _context.Context) KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest {
	return KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniTenantClusterAllocationResponse
 */
func (a *KubernetesApiService) GetKubernetesAciCniTenantClusterAllocationListExecute(r KubernetesApiApiGetKubernetesAciCniTenantClusterAllocationListRequest) (KubernetesAciCniTenantClusterAllocationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniTenantClusterAllocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAciCniTenantClusterAllocationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniTenantClusterAllocations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAddonDefinitionByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesAddonDefinitionByMoidRequest) Execute() (KubernetesAddonDefinition, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAddonDefinitionByMoidExecute(r)
}

/*
 * GetKubernetesAddonDefinitionByMoid Read a 'kubernetes.AddonDefinition' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesAddonDefinitionByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesAddonDefinitionByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesAddonDefinitionByMoidRequest {
	return KubernetesApiApiGetKubernetesAddonDefinitionByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonDefinition
 */
func (a *KubernetesApiService) GetKubernetesAddonDefinitionByMoidExecute(r KubernetesApiApiGetKubernetesAddonDefinitionByMoidRequest) (KubernetesAddonDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAddonDefinitionByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonDefinitions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAddonDefinitionListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Filter(filter string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Top(top int32) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Expand(expand string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Apply(apply string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Count(count bool) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) At(at string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Tags(tags string) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) Execute() (KubernetesAddonDefinitionResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAddonDefinitionListExecute(r)
}

/*
 * GetKubernetesAddonDefinitionList Read a 'kubernetes.AddonDefinition' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesAddonDefinitionListRequest
 */
func (a *KubernetesApiService) GetKubernetesAddonDefinitionList(ctx _context.Context) KubernetesApiApiGetKubernetesAddonDefinitionListRequest {
	return KubernetesApiApiGetKubernetesAddonDefinitionListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonDefinitionResponse
 */
func (a *KubernetesApiService) GetKubernetesAddonDefinitionListExecute(r KubernetesApiApiGetKubernetesAddonDefinitionListRequest) (KubernetesAddonDefinitionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAddonDefinitionList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonDefinitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAddonPolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesAddonPolicyByMoidRequest) Execute() (KubernetesAddonPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAddonPolicyByMoidExecute(r)
}

/*
 * GetKubernetesAddonPolicyByMoid Read a 'kubernetes.AddonPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesAddonPolicyByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesAddonPolicyByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesAddonPolicyByMoidRequest {
	return KubernetesApiApiGetKubernetesAddonPolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonPolicy
 */
func (a *KubernetesApiService) GetKubernetesAddonPolicyByMoidExecute(r KubernetesApiApiGetKubernetesAddonPolicyByMoidRequest) (KubernetesAddonPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAddonPolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAddonPolicyListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Filter(filter string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Top(top int32) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Expand(expand string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Apply(apply string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Count(count bool) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) At(at string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Tags(tags string) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesAddonPolicyListRequest) Execute() (KubernetesAddonPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAddonPolicyListExecute(r)
}

/*
 * GetKubernetesAddonPolicyList Read a 'kubernetes.AddonPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesAddonPolicyListRequest
 */
func (a *KubernetesApiService) GetKubernetesAddonPolicyList(ctx _context.Context) KubernetesApiApiGetKubernetesAddonPolicyListRequest {
	return KubernetesApiApiGetKubernetesAddonPolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonPolicyResponse
 */
func (a *KubernetesApiService) GetKubernetesAddonPolicyListExecute(r KubernetesApiApiGetKubernetesAddonPolicyListRequest) (KubernetesAddonPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAddonPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAddonRepositoryByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesAddonRepositoryByMoidRequest) Execute() (KubernetesAddonRepository, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAddonRepositoryByMoidExecute(r)
}

/*
 * GetKubernetesAddonRepositoryByMoid Read a 'kubernetes.AddonRepository' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesAddonRepositoryByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesAddonRepositoryByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesAddonRepositoryByMoidRequest {
	return KubernetesApiApiGetKubernetesAddonRepositoryByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonRepository
 */
func (a *KubernetesApiService) GetKubernetesAddonRepositoryByMoidExecute(r KubernetesApiApiGetKubernetesAddonRepositoryByMoidRequest) (KubernetesAddonRepository, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAddonRepositoryByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonRepositories/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesAddonRepositoryListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Filter(filter string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Top(top int32) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Expand(expand string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Apply(apply string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Count(count bool) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) At(at string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Tags(tags string) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) Execute() (KubernetesAddonRepositoryResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesAddonRepositoryListExecute(r)
}

/*
 * GetKubernetesAddonRepositoryList Read a 'kubernetes.AddonRepository' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesAddonRepositoryListRequest
 */
func (a *KubernetesApiService) GetKubernetesAddonRepositoryList(ctx _context.Context) KubernetesApiApiGetKubernetesAddonRepositoryListRequest {
	return KubernetesApiApiGetKubernetesAddonRepositoryListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonRepositoryResponse
 */
func (a *KubernetesApiService) GetKubernetesAddonRepositoryListExecute(r KubernetesApiApiGetKubernetesAddonRepositoryListRequest) (KubernetesAddonRepositoryResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonRepositoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesAddonRepositoryList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonRepositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesCatalogByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesCatalogByMoidRequest) Execute() (KubernetesCatalog, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesCatalogByMoidExecute(r)
}

/*
 * GetKubernetesCatalogByMoid Read a 'kubernetes.Catalog' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesCatalogByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesCatalogByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesCatalogByMoidRequest {
	return KubernetesApiApiGetKubernetesCatalogByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesCatalog
 */
func (a *KubernetesApiService) GetKubernetesCatalogByMoidExecute(r KubernetesApiApiGetKubernetesCatalogByMoidRequest) (KubernetesCatalog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesCatalogByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Catalogs/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesCatalogListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesCatalogListRequest) Filter(filter string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Top(top int32) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Expand(expand string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Apply(apply string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Count(count bool) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) At(at string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesCatalogListRequest) Tags(tags string) KubernetesApiApiGetKubernetesCatalogListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesCatalogListRequest) Execute() (KubernetesCatalogResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesCatalogListExecute(r)
}

/*
 * GetKubernetesCatalogList Read a 'kubernetes.Catalog' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesCatalogListRequest
 */
func (a *KubernetesApiService) GetKubernetesCatalogList(ctx _context.Context) KubernetesApiApiGetKubernetesCatalogListRequest {
	return KubernetesApiApiGetKubernetesCatalogListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesCatalogResponse
 */
func (a *KubernetesApiService) GetKubernetesCatalogListExecute(r KubernetesApiApiGetKubernetesCatalogListRequest) (KubernetesCatalogResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesCatalogResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesCatalogList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Catalogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesClusterAddonProfileByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesClusterAddonProfileByMoidRequest) Execute() (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesClusterAddonProfileByMoidExecute(r)
}

/*
 * GetKubernetesClusterAddonProfileByMoid Read a 'kubernetes.ClusterAddonProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesClusterAddonProfileByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesClusterAddonProfileByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesClusterAddonProfileByMoidRequest {
	return KubernetesApiApiGetKubernetesClusterAddonProfileByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterAddonProfile
 */
func (a *KubernetesApiService) GetKubernetesClusterAddonProfileByMoidExecute(r KubernetesApiApiGetKubernetesClusterAddonProfileByMoidRequest) (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterAddonProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesClusterAddonProfileByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterAddonProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesClusterAddonProfileListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Filter(filter string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Top(top int32) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Expand(expand string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Apply(apply string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Count(count bool) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) At(at string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Tags(tags string) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) Execute() (KubernetesClusterAddonProfileResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesClusterAddonProfileListExecute(r)
}

/*
 * GetKubernetesClusterAddonProfileList Read a 'kubernetes.ClusterAddonProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesClusterAddonProfileListRequest
 */
func (a *KubernetesApiService) GetKubernetesClusterAddonProfileList(ctx _context.Context) KubernetesApiApiGetKubernetesClusterAddonProfileListRequest {
	return KubernetesApiApiGetKubernetesClusterAddonProfileListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterAddonProfileResponse
 */
func (a *KubernetesApiService) GetKubernetesClusterAddonProfileListExecute(r KubernetesApiApiGetKubernetesClusterAddonProfileListRequest) (KubernetesClusterAddonProfileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterAddonProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesClusterAddonProfileList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterAddonProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesClusterByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesClusterByMoidRequest) Execute() (KubernetesCluster, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesClusterByMoidExecute(r)
}

/*
 * GetKubernetesClusterByMoid Read a 'kubernetes.Cluster' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesClusterByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesClusterByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesClusterByMoidRequest {
	return KubernetesApiApiGetKubernetesClusterByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesCluster
 */
func (a *KubernetesApiService) GetKubernetesClusterByMoidExecute(r KubernetesApiApiGetKubernetesClusterByMoidRequest) (KubernetesCluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesClusterByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Clusters/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesClusterListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesClusterListRequest) Filter(filter string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Top(top int32) KubernetesApiApiGetKubernetesClusterListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesClusterListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Expand(expand string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Apply(apply string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Count(count bool) KubernetesApiApiGetKubernetesClusterListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) At(at string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesClusterListRequest) Tags(tags string) KubernetesApiApiGetKubernetesClusterListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesClusterListRequest) Execute() (KubernetesClusterResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesClusterListExecute(r)
}

/*
 * GetKubernetesClusterList Read a 'kubernetes.Cluster' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesClusterListRequest
 */
func (a *KubernetesApiService) GetKubernetesClusterList(ctx _context.Context) KubernetesApiApiGetKubernetesClusterListRequest {
	return KubernetesApiApiGetKubernetesClusterListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterResponse
 */
func (a *KubernetesApiService) GetKubernetesClusterListExecute(r KubernetesApiApiGetKubernetesClusterListRequest) (KubernetesClusterResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesClusterList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesClusterProfileByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesClusterProfileByMoidRequest) Execute() (KubernetesClusterProfile, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesClusterProfileByMoidExecute(r)
}

/*
 * GetKubernetesClusterProfileByMoid Read a 'kubernetes.ClusterProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesClusterProfileByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesClusterProfileByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesClusterProfileByMoidRequest {
	return KubernetesApiApiGetKubernetesClusterProfileByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterProfile
 */
func (a *KubernetesApiService) GetKubernetesClusterProfileByMoidExecute(r KubernetesApiApiGetKubernetesClusterProfileByMoidRequest) (KubernetesClusterProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesClusterProfileByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesClusterProfileListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Filter(filter string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Top(top int32) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Expand(expand string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Apply(apply string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Count(count bool) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) At(at string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Tags(tags string) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesClusterProfileListRequest) Execute() (KubernetesClusterProfileResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesClusterProfileListExecute(r)
}

/*
 * GetKubernetesClusterProfileList Read a 'kubernetes.ClusterProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesClusterProfileListRequest
 */
func (a *KubernetesApiService) GetKubernetesClusterProfileList(ctx _context.Context) KubernetesApiApiGetKubernetesClusterProfileListRequest {
	return KubernetesApiApiGetKubernetesClusterProfileListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterProfileResponse
 */
func (a *KubernetesApiService) GetKubernetesClusterProfileListExecute(r KubernetesApiApiGetKubernetesClusterProfileListRequest) (KubernetesClusterProfileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesClusterProfileList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesConfigResultByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesConfigResultByMoidRequest) Execute() (KubernetesConfigResult, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesConfigResultByMoidExecute(r)
}

/*
 * GetKubernetesConfigResultByMoid Read a 'kubernetes.ConfigResult' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesConfigResultByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesConfigResultByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesConfigResultByMoidRequest {
	return KubernetesApiApiGetKubernetesConfigResultByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesConfigResult
 */
func (a *KubernetesApiService) GetKubernetesConfigResultByMoidExecute(r KubernetesApiApiGetKubernetesConfigResultByMoidRequest) (KubernetesConfigResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesConfigResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesConfigResultByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ConfigResults/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesConfigResultEntryByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesConfigResultEntryByMoidRequest) Execute() (KubernetesConfigResultEntry, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesConfigResultEntryByMoidExecute(r)
}

/*
 * GetKubernetesConfigResultEntryByMoid Read a 'kubernetes.ConfigResultEntry' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesConfigResultEntryByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesConfigResultEntryByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesConfigResultEntryByMoidRequest {
	return KubernetesApiApiGetKubernetesConfigResultEntryByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesConfigResultEntry
 */
func (a *KubernetesApiService) GetKubernetesConfigResultEntryByMoidExecute(r KubernetesApiApiGetKubernetesConfigResultEntryByMoidRequest) (KubernetesConfigResultEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesConfigResultEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesConfigResultEntryByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ConfigResultEntries/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesConfigResultEntryListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Filter(filter string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Top(top int32) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Expand(expand string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Apply(apply string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Count(count bool) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) At(at string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Tags(tags string) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) Execute() (KubernetesConfigResultEntryResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesConfigResultEntryListExecute(r)
}

/*
 * GetKubernetesConfigResultEntryList Read a 'kubernetes.ConfigResultEntry' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesConfigResultEntryListRequest
 */
func (a *KubernetesApiService) GetKubernetesConfigResultEntryList(ctx _context.Context) KubernetesApiApiGetKubernetesConfigResultEntryListRequest {
	return KubernetesApiApiGetKubernetesConfigResultEntryListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesConfigResultEntryResponse
 */
func (a *KubernetesApiService) GetKubernetesConfigResultEntryListExecute(r KubernetesApiApiGetKubernetesConfigResultEntryListRequest) (KubernetesConfigResultEntryResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesConfigResultEntryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesConfigResultEntryList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ConfigResultEntries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesConfigResultListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Filter(filter string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Top(top int32) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Expand(expand string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Apply(apply string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Count(count bool) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) At(at string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Tags(tags string) KubernetesApiApiGetKubernetesConfigResultListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesConfigResultListRequest) Execute() (KubernetesConfigResultResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesConfigResultListExecute(r)
}

/*
 * GetKubernetesConfigResultList Read a 'kubernetes.ConfigResult' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesConfigResultListRequest
 */
func (a *KubernetesApiService) GetKubernetesConfigResultList(ctx _context.Context) KubernetesApiApiGetKubernetesConfigResultListRequest {
	return KubernetesApiApiGetKubernetesConfigResultListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesConfigResultResponse
 */
func (a *KubernetesApiService) GetKubernetesConfigResultListExecute(r KubernetesApiApiGetKubernetesConfigResultListRequest) (KubernetesConfigResultResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesConfigResultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesConfigResultList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ConfigResults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesContainerRuntimePolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyByMoidRequest) Execute() (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesContainerRuntimePolicyByMoidExecute(r)
}

/*
 * GetKubernetesContainerRuntimePolicyByMoid Read a 'kubernetes.ContainerRuntimePolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesContainerRuntimePolicyByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesContainerRuntimePolicyByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesContainerRuntimePolicyByMoidRequest {
	return KubernetesApiApiGetKubernetesContainerRuntimePolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesContainerRuntimePolicy
 */
func (a *KubernetesApiService) GetKubernetesContainerRuntimePolicyByMoidExecute(r KubernetesApiApiGetKubernetesContainerRuntimePolicyByMoidRequest) (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesContainerRuntimePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesContainerRuntimePolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ContainerRuntimePolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Filter(filter string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Top(top int32) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Expand(expand string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Apply(apply string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Count(count bool) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) At(at string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Tags(tags string) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) Execute() (KubernetesContainerRuntimePolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesContainerRuntimePolicyListExecute(r)
}

/*
 * GetKubernetesContainerRuntimePolicyList Read a 'kubernetes.ContainerRuntimePolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest
 */
func (a *KubernetesApiService) GetKubernetesContainerRuntimePolicyList(ctx _context.Context) KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest {
	return KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesContainerRuntimePolicyResponse
 */
func (a *KubernetesApiService) GetKubernetesContainerRuntimePolicyListExecute(r KubernetesApiApiGetKubernetesContainerRuntimePolicyListRequest) (KubernetesContainerRuntimePolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesContainerRuntimePolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesContainerRuntimePolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ContainerRuntimePolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesDaemonSetByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesDaemonSetByMoidRequest) Execute() (KubernetesDaemonSet, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesDaemonSetByMoidExecute(r)
}

/*
 * GetKubernetesDaemonSetByMoid Read a 'kubernetes.DaemonSet' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesDaemonSetByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesDaemonSetByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesDaemonSetByMoidRequest {
	return KubernetesApiApiGetKubernetesDaemonSetByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesDaemonSet
 */
func (a *KubernetesApiService) GetKubernetesDaemonSetByMoidExecute(r KubernetesApiApiGetKubernetesDaemonSetByMoidRequest) (KubernetesDaemonSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesDaemonSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesDaemonSetByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/DaemonSets/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesDaemonSetListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Filter(filter string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Top(top int32) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Expand(expand string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Apply(apply string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Count(count bool) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) At(at string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Tags(tags string) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesDaemonSetListRequest) Execute() (KubernetesDaemonSetResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesDaemonSetListExecute(r)
}

/*
 * GetKubernetesDaemonSetList Read a 'kubernetes.DaemonSet' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesDaemonSetListRequest
 */
func (a *KubernetesApiService) GetKubernetesDaemonSetList(ctx _context.Context) KubernetesApiApiGetKubernetesDaemonSetListRequest {
	return KubernetesApiApiGetKubernetesDaemonSetListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesDaemonSetResponse
 */
func (a *KubernetesApiService) GetKubernetesDaemonSetListExecute(r KubernetesApiApiGetKubernetesDaemonSetListRequest) (KubernetesDaemonSetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesDaemonSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesDaemonSetList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/DaemonSets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesDeploymentByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesDeploymentByMoidRequest) Execute() (KubernetesDeployment, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesDeploymentByMoidExecute(r)
}

/*
 * GetKubernetesDeploymentByMoid Read a 'kubernetes.Deployment' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesDeploymentByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesDeploymentByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesDeploymentByMoidRequest {
	return KubernetesApiApiGetKubernetesDeploymentByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesDeployment
 */
func (a *KubernetesApiService) GetKubernetesDeploymentByMoidExecute(r KubernetesApiApiGetKubernetesDeploymentByMoidRequest) (KubernetesDeployment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesDeploymentByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Deployments/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesDeploymentListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Filter(filter string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Top(top int32) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Expand(expand string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Apply(apply string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Count(count bool) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) At(at string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Tags(tags string) KubernetesApiApiGetKubernetesDeploymentListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesDeploymentListRequest) Execute() (KubernetesDeploymentResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesDeploymentListExecute(r)
}

/*
 * GetKubernetesDeploymentList Read a 'kubernetes.Deployment' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesDeploymentListRequest
 */
func (a *KubernetesApiService) GetKubernetesDeploymentList(ctx _context.Context) KubernetesApiApiGetKubernetesDeploymentListRequest {
	return KubernetesApiApiGetKubernetesDeploymentListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesDeploymentResponse
 */
func (a *KubernetesApiService) GetKubernetesDeploymentListExecute(r KubernetesApiApiGetKubernetesDeploymentListRequest) (KubernetesDeploymentResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesDeploymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesDeploymentList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Deployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesIngressByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesIngressByMoidRequest) Execute() (KubernetesIngress, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesIngressByMoidExecute(r)
}

/*
 * GetKubernetesIngressByMoid Read a 'kubernetes.Ingress' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesIngressByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesIngressByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesIngressByMoidRequest {
	return KubernetesApiApiGetKubernetesIngressByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesIngress
 */
func (a *KubernetesApiService) GetKubernetesIngressByMoidExecute(r KubernetesApiApiGetKubernetesIngressByMoidRequest) (KubernetesIngress, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesIngress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesIngressByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Ingresses/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesIngressListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesIngressListRequest) Filter(filter string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Top(top int32) KubernetesApiApiGetKubernetesIngressListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesIngressListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Expand(expand string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Apply(apply string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Count(count bool) KubernetesApiApiGetKubernetesIngressListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) At(at string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesIngressListRequest) Tags(tags string) KubernetesApiApiGetKubernetesIngressListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesIngressListRequest) Execute() (KubernetesIngressResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesIngressListExecute(r)
}

/*
 * GetKubernetesIngressList Read a 'kubernetes.Ingress' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesIngressListRequest
 */
func (a *KubernetesApiService) GetKubernetesIngressList(ctx _context.Context) KubernetesApiApiGetKubernetesIngressListRequest {
	return KubernetesApiApiGetKubernetesIngressListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesIngressResponse
 */
func (a *KubernetesApiService) GetKubernetesIngressListExecute(r KubernetesApiApiGetKubernetesIngressListRequest) (KubernetesIngressResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesIngressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesIngressList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Ingresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesNetworkPolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesNetworkPolicyByMoidRequest) Execute() (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesNetworkPolicyByMoidExecute(r)
}

/*
 * GetKubernetesNetworkPolicyByMoid Read a 'kubernetes.NetworkPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesNetworkPolicyByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesNetworkPolicyByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesNetworkPolicyByMoidRequest {
	return KubernetesApiApiGetKubernetesNetworkPolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNetworkPolicy
 */
func (a *KubernetesApiService) GetKubernetesNetworkPolicyByMoidExecute(r KubernetesApiApiGetKubernetesNetworkPolicyByMoidRequest) (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNetworkPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesNetworkPolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NetworkPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesNetworkPolicyListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Filter(filter string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Top(top int32) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Expand(expand string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Apply(apply string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Count(count bool) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) At(at string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Tags(tags string) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) Execute() (KubernetesNetworkPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesNetworkPolicyListExecute(r)
}

/*
 * GetKubernetesNetworkPolicyList Read a 'kubernetes.NetworkPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesNetworkPolicyListRequest
 */
func (a *KubernetesApiService) GetKubernetesNetworkPolicyList(ctx _context.Context) KubernetesApiApiGetKubernetesNetworkPolicyListRequest {
	return KubernetesApiApiGetKubernetesNetworkPolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNetworkPolicyResponse
 */
func (a *KubernetesApiService) GetKubernetesNetworkPolicyListExecute(r KubernetesApiApiGetKubernetesNetworkPolicyListRequest) (KubernetesNetworkPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNetworkPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesNetworkPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NetworkPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesNodeByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesNodeByMoidRequest) Execute() (KubernetesNode, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesNodeByMoidExecute(r)
}

/*
 * GetKubernetesNodeByMoid Read a 'kubernetes.Node' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesNodeByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesNodeByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesNodeByMoidRequest {
	return KubernetesApiApiGetKubernetesNodeByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNode
 */
func (a *KubernetesApiService) GetKubernetesNodeByMoidExecute(r KubernetesApiApiGetKubernetesNodeByMoidRequest) (KubernetesNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesNodeByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Nodes/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesNodeGroupProfileByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesNodeGroupProfileByMoidRequest) Execute() (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesNodeGroupProfileByMoidExecute(r)
}

/*
 * GetKubernetesNodeGroupProfileByMoid Read a 'kubernetes.NodeGroupProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesNodeGroupProfileByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesNodeGroupProfileByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesNodeGroupProfileByMoidRequest {
	return KubernetesApiApiGetKubernetesNodeGroupProfileByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNodeGroupProfile
 */
func (a *KubernetesApiService) GetKubernetesNodeGroupProfileByMoidExecute(r KubernetesApiApiGetKubernetesNodeGroupProfileByMoidRequest) (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNodeGroupProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesNodeGroupProfileByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NodeGroupProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesNodeGroupProfileListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Filter(filter string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Top(top int32) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Expand(expand string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Apply(apply string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Count(count bool) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) At(at string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Tags(tags string) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) Execute() (KubernetesNodeGroupProfileResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesNodeGroupProfileListExecute(r)
}

/*
 * GetKubernetesNodeGroupProfileList Read a 'kubernetes.NodeGroupProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesNodeGroupProfileListRequest
 */
func (a *KubernetesApiService) GetKubernetesNodeGroupProfileList(ctx _context.Context) KubernetesApiApiGetKubernetesNodeGroupProfileListRequest {
	return KubernetesApiApiGetKubernetesNodeGroupProfileListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNodeGroupProfileResponse
 */
func (a *KubernetesApiService) GetKubernetesNodeGroupProfileListExecute(r KubernetesApiApiGetKubernetesNodeGroupProfileListRequest) (KubernetesNodeGroupProfileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNodeGroupProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesNodeGroupProfileList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NodeGroupProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesNodeListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesNodeListRequest) Filter(filter string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Top(top int32) KubernetesApiApiGetKubernetesNodeListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesNodeListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Expand(expand string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Apply(apply string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Count(count bool) KubernetesApiApiGetKubernetesNodeListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) At(at string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesNodeListRequest) Tags(tags string) KubernetesApiApiGetKubernetesNodeListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesNodeListRequest) Execute() (KubernetesNodeResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesNodeListExecute(r)
}

/*
 * GetKubernetesNodeList Read a 'kubernetes.Node' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesNodeListRequest
 */
func (a *KubernetesApiService) GetKubernetesNodeList(ctx _context.Context) KubernetesApiApiGetKubernetesNodeListRequest {
	return KubernetesApiApiGetKubernetesNodeListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNodeResponse
 */
func (a *KubernetesApiService) GetKubernetesNodeListExecute(r KubernetesApiApiGetKubernetesNodeListRequest) (KubernetesNodeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesNodeList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesPodByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesPodByMoidRequest) Execute() (KubernetesPod, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesPodByMoidExecute(r)
}

/*
 * GetKubernetesPodByMoid Read a 'kubernetes.Pod' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesPodByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesPodByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesPodByMoidRequest {
	return KubernetesApiApiGetKubernetesPodByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesPod
 */
func (a *KubernetesApiService) GetKubernetesPodByMoidExecute(r KubernetesApiApiGetKubernetesPodByMoidRequest) (KubernetesPod, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesPod
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesPodByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Pods/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesPodListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesPodListRequest) Filter(filter string) KubernetesApiApiGetKubernetesPodListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesPodListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Top(top int32) KubernetesApiApiGetKubernetesPodListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesPodListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesPodListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Expand(expand string) KubernetesApiApiGetKubernetesPodListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Apply(apply string) KubernetesApiApiGetKubernetesPodListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Count(count bool) KubernetesApiApiGetKubernetesPodListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesPodListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) At(at string) KubernetesApiApiGetKubernetesPodListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesPodListRequest) Tags(tags string) KubernetesApiApiGetKubernetesPodListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesPodListRequest) Execute() (KubernetesPodResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesPodListExecute(r)
}

/*
 * GetKubernetesPodList Read a 'kubernetes.Pod' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesPodListRequest
 */
func (a *KubernetesApiService) GetKubernetesPodList(ctx _context.Context) KubernetesApiApiGetKubernetesPodListRequest {
	return KubernetesApiApiGetKubernetesPodListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesPodResponse
 */
func (a *KubernetesApiService) GetKubernetesPodListExecute(r KubernetesApiApiGetKubernetesPodListRequest) (KubernetesPodResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesPodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesPodList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Pods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesServiceByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesServiceByMoidRequest) Execute() (KubernetesService, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesServiceByMoidExecute(r)
}

/*
 * GetKubernetesServiceByMoid Read a 'kubernetes.Service' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesServiceByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesServiceByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesServiceByMoidRequest {
	return KubernetesApiApiGetKubernetesServiceByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesService
 */
func (a *KubernetesApiService) GetKubernetesServiceByMoidExecute(r KubernetesApiApiGetKubernetesServiceByMoidRequest) (KubernetesService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesServiceByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Services/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesServiceListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesServiceListRequest) Filter(filter string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Top(top int32) KubernetesApiApiGetKubernetesServiceListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesServiceListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Expand(expand string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Apply(apply string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Count(count bool) KubernetesApiApiGetKubernetesServiceListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) At(at string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesServiceListRequest) Tags(tags string) KubernetesApiApiGetKubernetesServiceListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesServiceListRequest) Execute() (KubernetesServiceResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesServiceListExecute(r)
}

/*
 * GetKubernetesServiceList Read a 'kubernetes.Service' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesServiceListRequest
 */
func (a *KubernetesApiService) GetKubernetesServiceList(ctx _context.Context) KubernetesApiApiGetKubernetesServiceListRequest {
	return KubernetesApiApiGetKubernetesServiceListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesServiceResponse
 */
func (a *KubernetesApiService) GetKubernetesServiceListExecute(r KubernetesApiApiGetKubernetesServiceListRequest) (KubernetesServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesServiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesStatefulSetByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesStatefulSetByMoidRequest) Execute() (KubernetesStatefulSet, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesStatefulSetByMoidExecute(r)
}

/*
 * GetKubernetesStatefulSetByMoid Read a 'kubernetes.StatefulSet' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesStatefulSetByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesStatefulSetByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesStatefulSetByMoidRequest {
	return KubernetesApiApiGetKubernetesStatefulSetByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesStatefulSet
 */
func (a *KubernetesApiService) GetKubernetesStatefulSetByMoidExecute(r KubernetesApiApiGetKubernetesStatefulSetByMoidRequest) (KubernetesStatefulSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesStatefulSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesStatefulSetByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/StatefulSets/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesStatefulSetListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Filter(filter string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Top(top int32) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Expand(expand string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Apply(apply string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Count(count bool) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) At(at string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Tags(tags string) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesStatefulSetListRequest) Execute() (KubernetesStatefulSetResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesStatefulSetListExecute(r)
}

/*
 * GetKubernetesStatefulSetList Read a 'kubernetes.StatefulSet' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesStatefulSetListRequest
 */
func (a *KubernetesApiService) GetKubernetesStatefulSetList(ctx _context.Context) KubernetesApiApiGetKubernetesStatefulSetListRequest {
	return KubernetesApiApiGetKubernetesStatefulSetListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesStatefulSetResponse
 */
func (a *KubernetesApiService) GetKubernetesStatefulSetListExecute(r KubernetesApiApiGetKubernetesStatefulSetListRequest) (KubernetesStatefulSetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesStatefulSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesStatefulSetList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/StatefulSets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesSysConfigPolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesSysConfigPolicyByMoidRequest) Execute() (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesSysConfigPolicyByMoidExecute(r)
}

/*
 * GetKubernetesSysConfigPolicyByMoid Read a 'kubernetes.SysConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesSysConfigPolicyByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesSysConfigPolicyByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesSysConfigPolicyByMoidRequest {
	return KubernetesApiApiGetKubernetesSysConfigPolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesSysConfigPolicy
 */
func (a *KubernetesApiService) GetKubernetesSysConfigPolicyByMoidExecute(r KubernetesApiApiGetKubernetesSysConfigPolicyByMoidRequest) (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesSysConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesSysConfigPolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/SysConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesSysConfigPolicyListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Filter(filter string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Top(top int32) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Expand(expand string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Apply(apply string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Count(count bool) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) At(at string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Tags(tags string) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) Execute() (KubernetesSysConfigPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesSysConfigPolicyListExecute(r)
}

/*
 * GetKubernetesSysConfigPolicyList Read a 'kubernetes.SysConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesSysConfigPolicyListRequest
 */
func (a *KubernetesApiService) GetKubernetesSysConfigPolicyList(ctx _context.Context) KubernetesApiApiGetKubernetesSysConfigPolicyListRequest {
	return KubernetesApiApiGetKubernetesSysConfigPolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesSysConfigPolicyResponse
 */
func (a *KubernetesApiService) GetKubernetesSysConfigPolicyListExecute(r KubernetesApiApiGetKubernetesSysConfigPolicyListRequest) (KubernetesSysConfigPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesSysConfigPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesSysConfigPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/SysConfigPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesTrustedRegistriesPolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyByMoidRequest) Execute() (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesTrustedRegistriesPolicyByMoidExecute(r)
}

/*
 * GetKubernetesTrustedRegistriesPolicyByMoid Read a 'kubernetes.TrustedRegistriesPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesTrustedRegistriesPolicyByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesTrustedRegistriesPolicyByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyByMoidRequest {
	return KubernetesApiApiGetKubernetesTrustedRegistriesPolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesTrustedRegistriesPolicy
 */
func (a *KubernetesApiService) GetKubernetesTrustedRegistriesPolicyByMoidExecute(r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyByMoidRequest) (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesTrustedRegistriesPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesTrustedRegistriesPolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/TrustedRegistriesPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Filter(filter string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Top(top int32) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Expand(expand string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Apply(apply string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Count(count bool) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) At(at string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Tags(tags string) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) Execute() (KubernetesTrustedRegistriesPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesTrustedRegistriesPolicyListExecute(r)
}

/*
 * GetKubernetesTrustedRegistriesPolicyList Read a 'kubernetes.TrustedRegistriesPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest
 */
func (a *KubernetesApiService) GetKubernetesTrustedRegistriesPolicyList(ctx _context.Context) KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest {
	return KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesTrustedRegistriesPolicyResponse
 */
func (a *KubernetesApiService) GetKubernetesTrustedRegistriesPolicyListExecute(r KubernetesApiApiGetKubernetesTrustedRegistriesPolicyListRequest) (KubernetesTrustedRegistriesPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesTrustedRegistriesPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesTrustedRegistriesPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/TrustedRegistriesPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVersionByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesVersionByMoidRequest) Execute() (KubernetesVersion, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVersionByMoidExecute(r)
}

/*
 * GetKubernetesVersionByMoid Read a 'kubernetes.Version' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesVersionByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesVersionByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesVersionByMoidRequest {
	return KubernetesApiApiGetKubernetesVersionByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersion
 */
func (a *KubernetesApiService) GetKubernetesVersionByMoidExecute(r KubernetesApiApiGetKubernetesVersionByMoidRequest) (KubernetesVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVersionByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Versions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVersionListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesVersionListRequest) Filter(filter string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Top(top int32) KubernetesApiApiGetKubernetesVersionListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesVersionListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Expand(expand string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Apply(apply string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Count(count bool) KubernetesApiApiGetKubernetesVersionListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) At(at string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesVersionListRequest) Tags(tags string) KubernetesApiApiGetKubernetesVersionListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesVersionListRequest) Execute() (KubernetesVersionResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVersionListExecute(r)
}

/*
 * GetKubernetesVersionList Read a 'kubernetes.Version' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesVersionListRequest
 */
func (a *KubernetesApiService) GetKubernetesVersionList(ctx _context.Context) KubernetesApiApiGetKubernetesVersionListRequest {
	return KubernetesApiApiGetKubernetesVersionListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersionResponse
 */
func (a *KubernetesApiService) GetKubernetesVersionListExecute(r KubernetesApiApiGetKubernetesVersionListRequest) (KubernetesVersionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVersionList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Versions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVersionPolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesVersionPolicyByMoidRequest) Execute() (KubernetesVersionPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVersionPolicyByMoidExecute(r)
}

/*
 * GetKubernetesVersionPolicyByMoid Read a 'kubernetes.VersionPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesVersionPolicyByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesVersionPolicyByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesVersionPolicyByMoidRequest {
	return KubernetesApiApiGetKubernetesVersionPolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersionPolicy
 */
func (a *KubernetesApiService) GetKubernetesVersionPolicyByMoidExecute(r KubernetesApiApiGetKubernetesVersionPolicyByMoidRequest) (KubernetesVersionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVersionPolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VersionPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVersionPolicyListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Filter(filter string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Top(top int32) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Expand(expand string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Apply(apply string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Count(count bool) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) At(at string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Tags(tags string) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesVersionPolicyListRequest) Execute() (KubernetesVersionPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVersionPolicyListExecute(r)
}

/*
 * GetKubernetesVersionPolicyList Read a 'kubernetes.VersionPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesVersionPolicyListRequest
 */
func (a *KubernetesApiService) GetKubernetesVersionPolicyList(ctx _context.Context) KubernetesApiApiGetKubernetesVersionPolicyListRequest {
	return KubernetesApiApiGetKubernetesVersionPolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersionPolicyResponse
 */
func (a *KubernetesApiService) GetKubernetesVersionPolicyListExecute(r KubernetesApiApiGetKubernetesVersionPolicyListRequest) (KubernetesVersionPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersionPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVersionPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VersionPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyByMoidRequest) Execute() (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineInfraConfigPolicyByMoidExecute(r)
}

/*
 * GetKubernetesVirtualMachineInfraConfigPolicyByMoid Read a 'kubernetes.VirtualMachineInfraConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfraConfigPolicyByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyByMoidRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfraConfigPolicy
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfraConfigPolicyByMoidExecute(r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyByMoidRequest) (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfraConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineInfraConfigPolicyByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfraConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Filter(filter string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Top(top int32) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Expand(expand string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Apply(apply string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Count(count bool) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) At(at string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Tags(tags string) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) Execute() (KubernetesVirtualMachineInfraConfigPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineInfraConfigPolicyListExecute(r)
}

/*
 * GetKubernetesVirtualMachineInfraConfigPolicyList Read a 'kubernetes.VirtualMachineInfraConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfraConfigPolicyList(ctx _context.Context) KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfraConfigPolicyResponse
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfraConfigPolicyListExecute(r KubernetesApiApiGetKubernetesVirtualMachineInfraConfigPolicyListRequest) (KubernetesVirtualMachineInfraConfigPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfraConfigPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineInfraConfigPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfraConfigPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderByMoidRequest) Execute() (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineInfrastructureProviderByMoidExecute(r)
}

/*
 * GetKubernetesVirtualMachineInfrastructureProviderByMoid Read a 'kubernetes.VirtualMachineInfrastructureProvider' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfrastructureProviderByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderByMoidRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfrastructureProvider
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfrastructureProviderByMoidExecute(r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderByMoidRequest) (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfrastructureProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineInfrastructureProviderByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfrastructureProviders/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Filter(filter string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Top(top int32) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Expand(expand string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Apply(apply string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Count(count bool) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) At(at string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Tags(tags string) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) Execute() (KubernetesVirtualMachineInfrastructureProviderResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineInfrastructureProviderListExecute(r)
}

/*
 * GetKubernetesVirtualMachineInfrastructureProviderList Read a 'kubernetes.VirtualMachineInfrastructureProvider' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfrastructureProviderList(ctx _context.Context) KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfrastructureProviderResponse
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInfrastructureProviderListExecute(r KubernetesApiApiGetKubernetesVirtualMachineInfrastructureProviderListRequest) (KubernetesVirtualMachineInfrastructureProviderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfrastructureProviderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineInfrastructureProviderList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfrastructureProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeByMoidRequest) Execute() (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineInstanceTypeByMoidExecute(r)
}

/*
 * GetKubernetesVirtualMachineInstanceTypeByMoid Read a 'kubernetes.VirtualMachineInstanceType' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInstanceTypeByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeByMoidRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInstanceType
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInstanceTypeByMoidExecute(r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeByMoidRequest) (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineInstanceTypeByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInstanceTypes/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Filter(filter string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Top(top int32) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Expand(expand string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Apply(apply string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Count(count bool) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) At(at string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Tags(tags string) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) Execute() (KubernetesVirtualMachineInstanceTypeResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineInstanceTypeListExecute(r)
}

/*
 * GetKubernetesVirtualMachineInstanceTypeList Read a 'kubernetes.VirtualMachineInstanceType' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInstanceTypeList(ctx _context.Context) KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInstanceTypeResponse
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineInstanceTypeListExecute(r KubernetesApiApiGetKubernetesVirtualMachineInstanceTypeListRequest) (KubernetesVirtualMachineInstanceTypeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInstanceTypeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineInstanceTypeList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInstanceTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineNodeProfileByMoidRequest struct {
	ctx        _context.Context
	ApiService *KubernetesApiService
	moid       string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileByMoidRequest) Execute() (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineNodeProfileByMoidExecute(r)
}

/*
 * GetKubernetesVirtualMachineNodeProfileByMoid Read a 'kubernetes.VirtualMachineNodeProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiGetKubernetesVirtualMachineNodeProfileByMoidRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineNodeProfileByMoid(ctx _context.Context, moid string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileByMoidRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineNodeProfileByMoidRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineNodeProfile
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineNodeProfileByMoidExecute(r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileByMoidRequest) (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineNodeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineNodeProfileByMoid")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineNodeProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest struct {
	ctx         _context.Context
	ApiService  *KubernetesApiService
	filter      *string
	orderby     *string
	top         *int32
	skip        *int32
	select_     *string
	expand      *string
	apply       *string
	count       *bool
	inlinecount *string
	at          *string
	tags        *string
}

func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Filter(filter string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.filter = &filter
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Orderby(orderby string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.orderby = &orderby
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Top(top int32) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.top = &top
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Skip(skip int32) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.skip = &skip
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Select_(select_ string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.select_ = &select_
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Expand(expand string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.expand = &expand
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Apply(apply string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.apply = &apply
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Count(count bool) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.count = &count
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Inlinecount(inlinecount string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.inlinecount = &inlinecount
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) At(at string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.at = &at
	return r
}
func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Tags(tags string) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	r.tags = &tags
	return r
}

func (r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) Execute() (KubernetesVirtualMachineNodeProfileResponse, *_nethttp.Response, error) {
	return r.ApiService.GetKubernetesVirtualMachineNodeProfileListExecute(r)
}

/*
 * GetKubernetesVirtualMachineNodeProfileList Read a 'kubernetes.VirtualMachineNodeProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineNodeProfileList(ctx _context.Context) KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest {
	return KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineNodeProfileResponse
 */
func (a *KubernetesApiService) GetKubernetesVirtualMachineNodeProfileListExecute(r KubernetesApiApiGetKubernetesVirtualMachineNodeProfileListRequest) (KubernetesVirtualMachineNodeProfileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineNodeProfileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.GetKubernetesVirtualMachineNodeProfileList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineNodeProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("$filter", parameterToString(*r.filter, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("$orderby", parameterToString(*r.orderby, ""))
	}
	if r.top != nil {
		localVarQueryParams.Add("$top", parameterToString(*r.top, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	if r.select_ != nil {
		localVarQueryParams.Add("$select", parameterToString(*r.select_, ""))
	}
	if r.expand != nil {
		localVarQueryParams.Add("$expand", parameterToString(*r.expand, ""))
	}
	if r.apply != nil {
		localVarQueryParams.Add("$apply", parameterToString(*r.apply, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("$count", parameterToString(*r.count, ""))
	}
	if r.inlinecount != nil {
		localVarQueryParams.Add("$inlinecount", parameterToString(*r.inlinecount, ""))
	}
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesAciCniApicRequest struct {
	ctx                  _context.Context
	ApiService           *KubernetesApiService
	moid                 string
	kubernetesAciCniApic *KubernetesAciCniApic
	ifMatch              *string
}

func (r KubernetesApiApiPatchKubernetesAciCniApicRequest) KubernetesAciCniApic(kubernetesAciCniApic KubernetesAciCniApic) KubernetesApiApiPatchKubernetesAciCniApicRequest {
	r.kubernetesAciCniApic = &kubernetesAciCniApic
	return r
}
func (r KubernetesApiApiPatchKubernetesAciCniApicRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesAciCniApicRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesAciCniApicRequest) Execute() (KubernetesAciCniApic, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesAciCniApicExecute(r)
}

/*
 * PatchKubernetesAciCniApic Update a 'kubernetes.AciCniApic' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesAciCniApicRequest
 */
func (a *KubernetesApiService) PatchKubernetesAciCniApic(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesAciCniApicRequest {
	return KubernetesApiApiPatchKubernetesAciCniApicRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniApic
 */
func (a *KubernetesApiService) PatchKubernetesAciCniApicExecute(r KubernetesApiApiPatchKubernetesAciCniApicRequest) (KubernetesAciCniApic, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniApic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesAciCniApic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniApics/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniApic == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniApic is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniApic
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesAciCniProfileRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	moid                    string
	kubernetesAciCniProfile *KubernetesAciCniProfile
	ifMatch                 *string
}

func (r KubernetesApiApiPatchKubernetesAciCniProfileRequest) KubernetesAciCniProfile(kubernetesAciCniProfile KubernetesAciCniProfile) KubernetesApiApiPatchKubernetesAciCniProfileRequest {
	r.kubernetesAciCniProfile = &kubernetesAciCniProfile
	return r
}
func (r KubernetesApiApiPatchKubernetesAciCniProfileRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesAciCniProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesAciCniProfileRequest) Execute() (KubernetesAciCniProfile, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesAciCniProfileExecute(r)
}

/*
 * PatchKubernetesAciCniProfile Update a 'kubernetes.AciCniProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesAciCniProfileRequest
 */
func (a *KubernetesApiService) PatchKubernetesAciCniProfile(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesAciCniProfileRequest {
	return KubernetesApiApiPatchKubernetesAciCniProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniProfile
 */
func (a *KubernetesApiService) PatchKubernetesAciCniProfileExecute(r KubernetesApiApiPatchKubernetesAciCniProfileRequest) (KubernetesAciCniProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesAciCniProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest struct {
	ctx                                     _context.Context
	ApiService                              *KubernetesApiService
	moid                                    string
	kubernetesAciCniTenantClusterAllocation *KubernetesAciCniTenantClusterAllocation
	ifMatch                                 *string
}

func (r KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest) KubernetesAciCniTenantClusterAllocation(kubernetesAciCniTenantClusterAllocation KubernetesAciCniTenantClusterAllocation) KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest {
	r.kubernetesAciCniTenantClusterAllocation = &kubernetesAciCniTenantClusterAllocation
	return r
}
func (r KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest) Execute() (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesAciCniTenantClusterAllocationExecute(r)
}

/*
 * PatchKubernetesAciCniTenantClusterAllocation Update a 'kubernetes.AciCniTenantClusterAllocation' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest
 */
func (a *KubernetesApiService) PatchKubernetesAciCniTenantClusterAllocation(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest {
	return KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniTenantClusterAllocation
 */
func (a *KubernetesApiService) PatchKubernetesAciCniTenantClusterAllocationExecute(r KubernetesApiApiPatchKubernetesAciCniTenantClusterAllocationRequest) (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniTenantClusterAllocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesAciCniTenantClusterAllocation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniTenantClusterAllocations/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniTenantClusterAllocation == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniTenantClusterAllocation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniTenantClusterAllocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesAddonDefinitionRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	moid                      string
	kubernetesAddonDefinition *KubernetesAddonDefinition
	ifMatch                   *string
}

func (r KubernetesApiApiPatchKubernetesAddonDefinitionRequest) KubernetesAddonDefinition(kubernetesAddonDefinition KubernetesAddonDefinition) KubernetesApiApiPatchKubernetesAddonDefinitionRequest {
	r.kubernetesAddonDefinition = &kubernetesAddonDefinition
	return r
}
func (r KubernetesApiApiPatchKubernetesAddonDefinitionRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesAddonDefinitionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesAddonDefinitionRequest) Execute() (KubernetesAddonDefinition, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesAddonDefinitionExecute(r)
}

/*
 * PatchKubernetesAddonDefinition Update a 'kubernetes.AddonDefinition' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesAddonDefinitionRequest
 */
func (a *KubernetesApiService) PatchKubernetesAddonDefinition(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesAddonDefinitionRequest {
	return KubernetesApiApiPatchKubernetesAddonDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonDefinition
 */
func (a *KubernetesApiService) PatchKubernetesAddonDefinitionExecute(r KubernetesApiApiPatchKubernetesAddonDefinitionRequest) (KubernetesAddonDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesAddonDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonDefinitions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonDefinition == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesAddonPolicyRequest struct {
	ctx                   _context.Context
	ApiService            *KubernetesApiService
	moid                  string
	kubernetesAddonPolicy *KubernetesAddonPolicy
	ifMatch               *string
}

func (r KubernetesApiApiPatchKubernetesAddonPolicyRequest) KubernetesAddonPolicy(kubernetesAddonPolicy KubernetesAddonPolicy) KubernetesApiApiPatchKubernetesAddonPolicyRequest {
	r.kubernetesAddonPolicy = &kubernetesAddonPolicy
	return r
}
func (r KubernetesApiApiPatchKubernetesAddonPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesAddonPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesAddonPolicyRequest) Execute() (KubernetesAddonPolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesAddonPolicyExecute(r)
}

/*
 * PatchKubernetesAddonPolicy Update a 'kubernetes.AddonPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesAddonPolicyRequest
 */
func (a *KubernetesApiService) PatchKubernetesAddonPolicy(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesAddonPolicyRequest {
	return KubernetesApiApiPatchKubernetesAddonPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonPolicy
 */
func (a *KubernetesApiService) PatchKubernetesAddonPolicyExecute(r KubernetesApiApiPatchKubernetesAddonPolicyRequest) (KubernetesAddonPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesAddonPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesAddonRepositoryRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	moid                      string
	kubernetesAddonRepository *KubernetesAddonRepository
	ifMatch                   *string
}

func (r KubernetesApiApiPatchKubernetesAddonRepositoryRequest) KubernetesAddonRepository(kubernetesAddonRepository KubernetesAddonRepository) KubernetesApiApiPatchKubernetesAddonRepositoryRequest {
	r.kubernetesAddonRepository = &kubernetesAddonRepository
	return r
}
func (r KubernetesApiApiPatchKubernetesAddonRepositoryRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesAddonRepositoryRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesAddonRepositoryRequest) Execute() (KubernetesAddonRepository, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesAddonRepositoryExecute(r)
}

/*
 * PatchKubernetesAddonRepository Update a 'kubernetes.AddonRepository' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesAddonRepositoryRequest
 */
func (a *KubernetesApiService) PatchKubernetesAddonRepository(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesAddonRepositoryRequest {
	return KubernetesApiApiPatchKubernetesAddonRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonRepository
 */
func (a *KubernetesApiService) PatchKubernetesAddonRepositoryExecute(r KubernetesApiApiPatchKubernetesAddonRepositoryRequest) (KubernetesAddonRepository, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesAddonRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonRepositories/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonRepository == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesClusterRequest struct {
	ctx               _context.Context
	ApiService        *KubernetesApiService
	moid              string
	kubernetesCluster *KubernetesCluster
	ifMatch           *string
}

func (r KubernetesApiApiPatchKubernetesClusterRequest) KubernetesCluster(kubernetesCluster KubernetesCluster) KubernetesApiApiPatchKubernetesClusterRequest {
	r.kubernetesCluster = &kubernetesCluster
	return r
}
func (r KubernetesApiApiPatchKubernetesClusterRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesClusterRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesClusterRequest) Execute() (KubernetesCluster, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesClusterExecute(r)
}

/*
 * PatchKubernetesCluster Update a 'kubernetes.Cluster' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesClusterRequest
 */
func (a *KubernetesApiService) PatchKubernetesCluster(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesClusterRequest {
	return KubernetesApiApiPatchKubernetesClusterRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesCluster
 */
func (a *KubernetesApiService) PatchKubernetesClusterExecute(r KubernetesApiApiPatchKubernetesClusterRequest) (KubernetesCluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesCluster")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Clusters/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesCluster == nil {
		return localVarReturnValue, nil, reportError("kubernetesCluster is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesCluster
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesClusterAddonProfileRequest struct {
	ctx                           _context.Context
	ApiService                    *KubernetesApiService
	moid                          string
	kubernetesClusterAddonProfile *KubernetesClusterAddonProfile
	ifMatch                       *string
}

func (r KubernetesApiApiPatchKubernetesClusterAddonProfileRequest) KubernetesClusterAddonProfile(kubernetesClusterAddonProfile KubernetesClusterAddonProfile) KubernetesApiApiPatchKubernetesClusterAddonProfileRequest {
	r.kubernetesClusterAddonProfile = &kubernetesClusterAddonProfile
	return r
}
func (r KubernetesApiApiPatchKubernetesClusterAddonProfileRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesClusterAddonProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesClusterAddonProfileRequest) Execute() (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesClusterAddonProfileExecute(r)
}

/*
 * PatchKubernetesClusterAddonProfile Update a 'kubernetes.ClusterAddonProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesClusterAddonProfileRequest
 */
func (a *KubernetesApiService) PatchKubernetesClusterAddonProfile(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesClusterAddonProfileRequest {
	return KubernetesApiApiPatchKubernetesClusterAddonProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterAddonProfile
 */
func (a *KubernetesApiService) PatchKubernetesClusterAddonProfileExecute(r KubernetesApiApiPatchKubernetesClusterAddonProfileRequest) (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterAddonProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesClusterAddonProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterAddonProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesClusterAddonProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesClusterAddonProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesClusterAddonProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesClusterProfileRequest struct {
	ctx                      _context.Context
	ApiService               *KubernetesApiService
	moid                     string
	kubernetesClusterProfile *KubernetesClusterProfile
	ifMatch                  *string
}

func (r KubernetesApiApiPatchKubernetesClusterProfileRequest) KubernetesClusterProfile(kubernetesClusterProfile KubernetesClusterProfile) KubernetesApiApiPatchKubernetesClusterProfileRequest {
	r.kubernetesClusterProfile = &kubernetesClusterProfile
	return r
}
func (r KubernetesApiApiPatchKubernetesClusterProfileRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesClusterProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesClusterProfileRequest) Execute() (KubernetesClusterProfile, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesClusterProfileExecute(r)
}

/*
 * PatchKubernetesClusterProfile Update a 'kubernetes.ClusterProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesClusterProfileRequest
 */
func (a *KubernetesApiService) PatchKubernetesClusterProfile(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesClusterProfileRequest {
	return KubernetesApiApiPatchKubernetesClusterProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterProfile
 */
func (a *KubernetesApiService) PatchKubernetesClusterProfileExecute(r KubernetesApiApiPatchKubernetesClusterProfileRequest) (KubernetesClusterProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesClusterProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesClusterProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesClusterProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesClusterProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest struct {
	ctx                              _context.Context
	ApiService                       *KubernetesApiService
	moid                             string
	kubernetesContainerRuntimePolicy *KubernetesContainerRuntimePolicy
	ifMatch                          *string
}

func (r KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest) KubernetesContainerRuntimePolicy(kubernetesContainerRuntimePolicy KubernetesContainerRuntimePolicy) KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest {
	r.kubernetesContainerRuntimePolicy = &kubernetesContainerRuntimePolicy
	return r
}
func (r KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest) Execute() (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesContainerRuntimePolicyExecute(r)
}

/*
 * PatchKubernetesContainerRuntimePolicy Update a 'kubernetes.ContainerRuntimePolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest
 */
func (a *KubernetesApiService) PatchKubernetesContainerRuntimePolicy(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest {
	return KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesContainerRuntimePolicy
 */
func (a *KubernetesApiService) PatchKubernetesContainerRuntimePolicyExecute(r KubernetesApiApiPatchKubernetesContainerRuntimePolicyRequest) (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesContainerRuntimePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesContainerRuntimePolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ContainerRuntimePolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesContainerRuntimePolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesContainerRuntimePolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesContainerRuntimePolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesNetworkPolicyRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	moid                    string
	kubernetesNetworkPolicy *KubernetesNetworkPolicy
	ifMatch                 *string
}

func (r KubernetesApiApiPatchKubernetesNetworkPolicyRequest) KubernetesNetworkPolicy(kubernetesNetworkPolicy KubernetesNetworkPolicy) KubernetesApiApiPatchKubernetesNetworkPolicyRequest {
	r.kubernetesNetworkPolicy = &kubernetesNetworkPolicy
	return r
}
func (r KubernetesApiApiPatchKubernetesNetworkPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesNetworkPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesNetworkPolicyRequest) Execute() (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesNetworkPolicyExecute(r)
}

/*
 * PatchKubernetesNetworkPolicy Update a 'kubernetes.NetworkPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesNetworkPolicyRequest
 */
func (a *KubernetesApiService) PatchKubernetesNetworkPolicy(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesNetworkPolicyRequest {
	return KubernetesApiApiPatchKubernetesNetworkPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNetworkPolicy
 */
func (a *KubernetesApiService) PatchKubernetesNetworkPolicyExecute(r KubernetesApiApiPatchKubernetesNetworkPolicyRequest) (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNetworkPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesNetworkPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NetworkPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesNetworkPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesNetworkPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesNetworkPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesNodeGroupProfileRequest struct {
	ctx                        _context.Context
	ApiService                 *KubernetesApiService
	moid                       string
	kubernetesNodeGroupProfile *KubernetesNodeGroupProfile
	ifMatch                    *string
}

func (r KubernetesApiApiPatchKubernetesNodeGroupProfileRequest) KubernetesNodeGroupProfile(kubernetesNodeGroupProfile KubernetesNodeGroupProfile) KubernetesApiApiPatchKubernetesNodeGroupProfileRequest {
	r.kubernetesNodeGroupProfile = &kubernetesNodeGroupProfile
	return r
}
func (r KubernetesApiApiPatchKubernetesNodeGroupProfileRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesNodeGroupProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesNodeGroupProfileRequest) Execute() (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesNodeGroupProfileExecute(r)
}

/*
 * PatchKubernetesNodeGroupProfile Update a 'kubernetes.NodeGroupProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesNodeGroupProfileRequest
 */
func (a *KubernetesApiService) PatchKubernetesNodeGroupProfile(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesNodeGroupProfileRequest {
	return KubernetesApiApiPatchKubernetesNodeGroupProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNodeGroupProfile
 */
func (a *KubernetesApiService) PatchKubernetesNodeGroupProfileExecute(r KubernetesApiApiPatchKubernetesNodeGroupProfileRequest) (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNodeGroupProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesNodeGroupProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NodeGroupProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesNodeGroupProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesNodeGroupProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesNodeGroupProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesSysConfigPolicyRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	moid                      string
	kubernetesSysConfigPolicy *KubernetesSysConfigPolicy
	ifMatch                   *string
}

func (r KubernetesApiApiPatchKubernetesSysConfigPolicyRequest) KubernetesSysConfigPolicy(kubernetesSysConfigPolicy KubernetesSysConfigPolicy) KubernetesApiApiPatchKubernetesSysConfigPolicyRequest {
	r.kubernetesSysConfigPolicy = &kubernetesSysConfigPolicy
	return r
}
func (r KubernetesApiApiPatchKubernetesSysConfigPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesSysConfigPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesSysConfigPolicyRequest) Execute() (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesSysConfigPolicyExecute(r)
}

/*
 * PatchKubernetesSysConfigPolicy Update a 'kubernetes.SysConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesSysConfigPolicyRequest
 */
func (a *KubernetesApiService) PatchKubernetesSysConfigPolicy(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesSysConfigPolicyRequest {
	return KubernetesApiApiPatchKubernetesSysConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesSysConfigPolicy
 */
func (a *KubernetesApiService) PatchKubernetesSysConfigPolicyExecute(r KubernetesApiApiPatchKubernetesSysConfigPolicyRequest) (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesSysConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesSysConfigPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/SysConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesSysConfigPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesSysConfigPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesSysConfigPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest struct {
	ctx                               _context.Context
	ApiService                        *KubernetesApiService
	moid                              string
	kubernetesTrustedRegistriesPolicy *KubernetesTrustedRegistriesPolicy
	ifMatch                           *string
}

func (r KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest) KubernetesTrustedRegistriesPolicy(kubernetesTrustedRegistriesPolicy KubernetesTrustedRegistriesPolicy) KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest {
	r.kubernetesTrustedRegistriesPolicy = &kubernetesTrustedRegistriesPolicy
	return r
}
func (r KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest) Execute() (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesTrustedRegistriesPolicyExecute(r)
}

/*
 * PatchKubernetesTrustedRegistriesPolicy Update a 'kubernetes.TrustedRegistriesPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest
 */
func (a *KubernetesApiService) PatchKubernetesTrustedRegistriesPolicy(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest {
	return KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesTrustedRegistriesPolicy
 */
func (a *KubernetesApiService) PatchKubernetesTrustedRegistriesPolicyExecute(r KubernetesApiApiPatchKubernetesTrustedRegistriesPolicyRequest) (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesTrustedRegistriesPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesTrustedRegistriesPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/TrustedRegistriesPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesTrustedRegistriesPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesTrustedRegistriesPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesTrustedRegistriesPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesVersionRequest struct {
	ctx               _context.Context
	ApiService        *KubernetesApiService
	moid              string
	kubernetesVersion *KubernetesVersion
	ifMatch           *string
}

func (r KubernetesApiApiPatchKubernetesVersionRequest) KubernetesVersion(kubernetesVersion KubernetesVersion) KubernetesApiApiPatchKubernetesVersionRequest {
	r.kubernetesVersion = &kubernetesVersion
	return r
}
func (r KubernetesApiApiPatchKubernetesVersionRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesVersionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesVersionRequest) Execute() (KubernetesVersion, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesVersionExecute(r)
}

/*
 * PatchKubernetesVersion Update a 'kubernetes.Version' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesVersionRequest
 */
func (a *KubernetesApiService) PatchKubernetesVersion(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesVersionRequest {
	return KubernetesApiApiPatchKubernetesVersionRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersion
 */
func (a *KubernetesApiService) PatchKubernetesVersionExecute(r KubernetesApiApiPatchKubernetesVersionRequest) (KubernetesVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Versions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVersion == nil {
		return localVarReturnValue, nil, reportError("kubernetesVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesVersionPolicyRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	moid                    string
	kubernetesVersionPolicy *KubernetesVersionPolicy
	ifMatch                 *string
}

func (r KubernetesApiApiPatchKubernetesVersionPolicyRequest) KubernetesVersionPolicy(kubernetesVersionPolicy KubernetesVersionPolicy) KubernetesApiApiPatchKubernetesVersionPolicyRequest {
	r.kubernetesVersionPolicy = &kubernetesVersionPolicy
	return r
}
func (r KubernetesApiApiPatchKubernetesVersionPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesVersionPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesVersionPolicyRequest) Execute() (KubernetesVersionPolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesVersionPolicyExecute(r)
}

/*
 * PatchKubernetesVersionPolicy Update a 'kubernetes.VersionPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesVersionPolicyRequest
 */
func (a *KubernetesApiService) PatchKubernetesVersionPolicy(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesVersionPolicyRequest {
	return KubernetesApiApiPatchKubernetesVersionPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersionPolicy
 */
func (a *KubernetesApiService) PatchKubernetesVersionPolicyExecute(r KubernetesApiApiPatchKubernetesVersionPolicyRequest) (KubernetesVersionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesVersionPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VersionPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVersionPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesVersionPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVersionPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest struct {
	ctx                                       _context.Context
	ApiService                                *KubernetesApiService
	moid                                      string
	kubernetesVirtualMachineInfraConfigPolicy *KubernetesVirtualMachineInfraConfigPolicy
	ifMatch                                   *string
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest) KubernetesVirtualMachineInfraConfigPolicy(kubernetesVirtualMachineInfraConfigPolicy KubernetesVirtualMachineInfraConfigPolicy) KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest {
	r.kubernetesVirtualMachineInfraConfigPolicy = &kubernetesVirtualMachineInfraConfigPolicy
	return r
}
func (r KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest) Execute() (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesVirtualMachineInfraConfigPolicyExecute(r)
}

/*
 * PatchKubernetesVirtualMachineInfraConfigPolicy Update a 'kubernetes.VirtualMachineInfraConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineInfraConfigPolicy(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest {
	return KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfraConfigPolicy
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineInfraConfigPolicyExecute(r KubernetesApiApiPatchKubernetesVirtualMachineInfraConfigPolicyRequest) (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfraConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesVirtualMachineInfraConfigPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfraConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInfraConfigPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInfraConfigPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInfraConfigPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest struct {
	ctx                                            _context.Context
	ApiService                                     *KubernetesApiService
	moid                                           string
	kubernetesVirtualMachineInfrastructureProvider *KubernetesVirtualMachineInfrastructureProvider
	ifMatch                                        *string
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest) KubernetesVirtualMachineInfrastructureProvider(kubernetesVirtualMachineInfrastructureProvider KubernetesVirtualMachineInfrastructureProvider) KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest {
	r.kubernetesVirtualMachineInfrastructureProvider = &kubernetesVirtualMachineInfrastructureProvider
	return r
}
func (r KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest) Execute() (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesVirtualMachineInfrastructureProviderExecute(r)
}

/*
 * PatchKubernetesVirtualMachineInfrastructureProvider Update a 'kubernetes.VirtualMachineInfrastructureProvider' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineInfrastructureProvider(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest {
	return KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfrastructureProvider
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineInfrastructureProviderExecute(r KubernetesApiApiPatchKubernetesVirtualMachineInfrastructureProviderRequest) (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfrastructureProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesVirtualMachineInfrastructureProvider")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfrastructureProviders/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInfrastructureProvider == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInfrastructureProvider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInfrastructureProvider
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest struct {
	ctx                                  _context.Context
	ApiService                           *KubernetesApiService
	moid                                 string
	kubernetesVirtualMachineInstanceType *KubernetesVirtualMachineInstanceType
	ifMatch                              *string
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest) KubernetesVirtualMachineInstanceType(kubernetesVirtualMachineInstanceType KubernetesVirtualMachineInstanceType) KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest {
	r.kubernetesVirtualMachineInstanceType = &kubernetesVirtualMachineInstanceType
	return r
}
func (r KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest) Execute() (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesVirtualMachineInstanceTypeExecute(r)
}

/*
 * PatchKubernetesVirtualMachineInstanceType Update a 'kubernetes.VirtualMachineInstanceType' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineInstanceType(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest {
	return KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInstanceType
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineInstanceTypeExecute(r KubernetesApiApiPatchKubernetesVirtualMachineInstanceTypeRequest) (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesVirtualMachineInstanceType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInstanceTypes/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInstanceType == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInstanceType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInstanceType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest struct {
	ctx                                 _context.Context
	ApiService                          *KubernetesApiService
	moid                                string
	kubernetesVirtualMachineNodeProfile *KubernetesVirtualMachineNodeProfile
	ifMatch                             *string
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest) KubernetesVirtualMachineNodeProfile(kubernetesVirtualMachineNodeProfile KubernetesVirtualMachineNodeProfile) KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest {
	r.kubernetesVirtualMachineNodeProfile = &kubernetesVirtualMachineNodeProfile
	return r
}
func (r KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest) IfMatch(ifMatch string) KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest) Execute() (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	return r.ApiService.PatchKubernetesVirtualMachineNodeProfileExecute(r)
}

/*
 * PatchKubernetesVirtualMachineNodeProfile Update a 'kubernetes.VirtualMachineNodeProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineNodeProfile(ctx _context.Context, moid string) KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest {
	return KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineNodeProfile
 */
func (a *KubernetesApiService) PatchKubernetesVirtualMachineNodeProfileExecute(r KubernetesApiApiPatchKubernetesVirtualMachineNodeProfileRequest) (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineNodeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.PatchKubernetesVirtualMachineNodeProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineNodeProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineNodeProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineNodeProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineNodeProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesAciCniApicRequest struct {
	ctx                  _context.Context
	ApiService           *KubernetesApiService
	moid                 string
	kubernetesAciCniApic *KubernetesAciCniApic
	ifMatch              *string
}

func (r KubernetesApiApiUpdateKubernetesAciCniApicRequest) KubernetesAciCniApic(kubernetesAciCniApic KubernetesAciCniApic) KubernetesApiApiUpdateKubernetesAciCniApicRequest {
	r.kubernetesAciCniApic = &kubernetesAciCniApic
	return r
}
func (r KubernetesApiApiUpdateKubernetesAciCniApicRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesAciCniApicRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesAciCniApicRequest) Execute() (KubernetesAciCniApic, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesAciCniApicExecute(r)
}

/*
 * UpdateKubernetesAciCniApic Update a 'kubernetes.AciCniApic' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesAciCniApicRequest
 */
func (a *KubernetesApiService) UpdateKubernetesAciCniApic(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesAciCniApicRequest {
	return KubernetesApiApiUpdateKubernetesAciCniApicRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniApic
 */
func (a *KubernetesApiService) UpdateKubernetesAciCniApicExecute(r KubernetesApiApiUpdateKubernetesAciCniApicRequest) (KubernetesAciCniApic, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniApic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesAciCniApic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniApics/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniApic == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniApic is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniApic
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesAciCniProfileRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	moid                    string
	kubernetesAciCniProfile *KubernetesAciCniProfile
	ifMatch                 *string
}

func (r KubernetesApiApiUpdateKubernetesAciCniProfileRequest) KubernetesAciCniProfile(kubernetesAciCniProfile KubernetesAciCniProfile) KubernetesApiApiUpdateKubernetesAciCniProfileRequest {
	r.kubernetesAciCniProfile = &kubernetesAciCniProfile
	return r
}
func (r KubernetesApiApiUpdateKubernetesAciCniProfileRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesAciCniProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesAciCniProfileRequest) Execute() (KubernetesAciCniProfile, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesAciCniProfileExecute(r)
}

/*
 * UpdateKubernetesAciCniProfile Update a 'kubernetes.AciCniProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesAciCniProfileRequest
 */
func (a *KubernetesApiService) UpdateKubernetesAciCniProfile(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesAciCniProfileRequest {
	return KubernetesApiApiUpdateKubernetesAciCniProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniProfile
 */
func (a *KubernetesApiService) UpdateKubernetesAciCniProfileExecute(r KubernetesApiApiUpdateKubernetesAciCniProfileRequest) (KubernetesAciCniProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesAciCniProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest struct {
	ctx                                     _context.Context
	ApiService                              *KubernetesApiService
	moid                                    string
	kubernetesAciCniTenantClusterAllocation *KubernetesAciCniTenantClusterAllocation
	ifMatch                                 *string
}

func (r KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest) KubernetesAciCniTenantClusterAllocation(kubernetesAciCniTenantClusterAllocation KubernetesAciCniTenantClusterAllocation) KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest {
	r.kubernetesAciCniTenantClusterAllocation = &kubernetesAciCniTenantClusterAllocation
	return r
}
func (r KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest) Execute() (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesAciCniTenantClusterAllocationExecute(r)
}

/*
 * UpdateKubernetesAciCniTenantClusterAllocation Update a 'kubernetes.AciCniTenantClusterAllocation' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest
 */
func (a *KubernetesApiService) UpdateKubernetesAciCniTenantClusterAllocation(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest {
	return KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAciCniTenantClusterAllocation
 */
func (a *KubernetesApiService) UpdateKubernetesAciCniTenantClusterAllocationExecute(r KubernetesApiApiUpdateKubernetesAciCniTenantClusterAllocationRequest) (KubernetesAciCniTenantClusterAllocation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAciCniTenantClusterAllocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesAciCniTenantClusterAllocation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AciCniTenantClusterAllocations/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAciCniTenantClusterAllocation == nil {
		return localVarReturnValue, nil, reportError("kubernetesAciCniTenantClusterAllocation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAciCniTenantClusterAllocation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesAddonDefinitionRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	moid                      string
	kubernetesAddonDefinition *KubernetesAddonDefinition
	ifMatch                   *string
}

func (r KubernetesApiApiUpdateKubernetesAddonDefinitionRequest) KubernetesAddonDefinition(kubernetesAddonDefinition KubernetesAddonDefinition) KubernetesApiApiUpdateKubernetesAddonDefinitionRequest {
	r.kubernetesAddonDefinition = &kubernetesAddonDefinition
	return r
}
func (r KubernetesApiApiUpdateKubernetesAddonDefinitionRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesAddonDefinitionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesAddonDefinitionRequest) Execute() (KubernetesAddonDefinition, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesAddonDefinitionExecute(r)
}

/*
 * UpdateKubernetesAddonDefinition Update a 'kubernetes.AddonDefinition' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesAddonDefinitionRequest
 */
func (a *KubernetesApiService) UpdateKubernetesAddonDefinition(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesAddonDefinitionRequest {
	return KubernetesApiApiUpdateKubernetesAddonDefinitionRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonDefinition
 */
func (a *KubernetesApiService) UpdateKubernetesAddonDefinitionExecute(r KubernetesApiApiUpdateKubernetesAddonDefinitionRequest) (KubernetesAddonDefinition, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesAddonDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonDefinitions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonDefinition == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonDefinition is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesAddonPolicyRequest struct {
	ctx                   _context.Context
	ApiService            *KubernetesApiService
	moid                  string
	kubernetesAddonPolicy *KubernetesAddonPolicy
	ifMatch               *string
}

func (r KubernetesApiApiUpdateKubernetesAddonPolicyRequest) KubernetesAddonPolicy(kubernetesAddonPolicy KubernetesAddonPolicy) KubernetesApiApiUpdateKubernetesAddonPolicyRequest {
	r.kubernetesAddonPolicy = &kubernetesAddonPolicy
	return r
}
func (r KubernetesApiApiUpdateKubernetesAddonPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesAddonPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesAddonPolicyRequest) Execute() (KubernetesAddonPolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesAddonPolicyExecute(r)
}

/*
 * UpdateKubernetesAddonPolicy Update a 'kubernetes.AddonPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesAddonPolicyRequest
 */
func (a *KubernetesApiService) UpdateKubernetesAddonPolicy(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesAddonPolicyRequest {
	return KubernetesApiApiUpdateKubernetesAddonPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonPolicy
 */
func (a *KubernetesApiService) UpdateKubernetesAddonPolicyExecute(r KubernetesApiApiUpdateKubernetesAddonPolicyRequest) (KubernetesAddonPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesAddonPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesAddonRepositoryRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	moid                      string
	kubernetesAddonRepository *KubernetesAddonRepository
	ifMatch                   *string
}

func (r KubernetesApiApiUpdateKubernetesAddonRepositoryRequest) KubernetesAddonRepository(kubernetesAddonRepository KubernetesAddonRepository) KubernetesApiApiUpdateKubernetesAddonRepositoryRequest {
	r.kubernetesAddonRepository = &kubernetesAddonRepository
	return r
}
func (r KubernetesApiApiUpdateKubernetesAddonRepositoryRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesAddonRepositoryRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesAddonRepositoryRequest) Execute() (KubernetesAddonRepository, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesAddonRepositoryExecute(r)
}

/*
 * UpdateKubernetesAddonRepository Update a 'kubernetes.AddonRepository' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesAddonRepositoryRequest
 */
func (a *KubernetesApiService) UpdateKubernetesAddonRepository(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesAddonRepositoryRequest {
	return KubernetesApiApiUpdateKubernetesAddonRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesAddonRepository
 */
func (a *KubernetesApiService) UpdateKubernetesAddonRepositoryExecute(r KubernetesApiApiUpdateKubernetesAddonRepositoryRequest) (KubernetesAddonRepository, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesAddonRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesAddonRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/AddonRepositories/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesAddonRepository == nil {
		return localVarReturnValue, nil, reportError("kubernetesAddonRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesAddonRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesClusterRequest struct {
	ctx               _context.Context
	ApiService        *KubernetesApiService
	moid              string
	kubernetesCluster *KubernetesCluster
	ifMatch           *string
}

func (r KubernetesApiApiUpdateKubernetesClusterRequest) KubernetesCluster(kubernetesCluster KubernetesCluster) KubernetesApiApiUpdateKubernetesClusterRequest {
	r.kubernetesCluster = &kubernetesCluster
	return r
}
func (r KubernetesApiApiUpdateKubernetesClusterRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesClusterRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesClusterRequest) Execute() (KubernetesCluster, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesClusterExecute(r)
}

/*
 * UpdateKubernetesCluster Update a 'kubernetes.Cluster' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesClusterRequest
 */
func (a *KubernetesApiService) UpdateKubernetesCluster(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesClusterRequest {
	return KubernetesApiApiUpdateKubernetesClusterRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesCluster
 */
func (a *KubernetesApiService) UpdateKubernetesClusterExecute(r KubernetesApiApiUpdateKubernetesClusterRequest) (KubernetesCluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesCluster")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Clusters/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesCluster == nil {
		return localVarReturnValue, nil, reportError("kubernetesCluster is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesCluster
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest struct {
	ctx                           _context.Context
	ApiService                    *KubernetesApiService
	moid                          string
	kubernetesClusterAddonProfile *KubernetesClusterAddonProfile
	ifMatch                       *string
}

func (r KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest) KubernetesClusterAddonProfile(kubernetesClusterAddonProfile KubernetesClusterAddonProfile) KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest {
	r.kubernetesClusterAddonProfile = &kubernetesClusterAddonProfile
	return r
}
func (r KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest) Execute() (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesClusterAddonProfileExecute(r)
}

/*
 * UpdateKubernetesClusterAddonProfile Update a 'kubernetes.ClusterAddonProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest
 */
func (a *KubernetesApiService) UpdateKubernetesClusterAddonProfile(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest {
	return KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterAddonProfile
 */
func (a *KubernetesApiService) UpdateKubernetesClusterAddonProfileExecute(r KubernetesApiApiUpdateKubernetesClusterAddonProfileRequest) (KubernetesClusterAddonProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterAddonProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesClusterAddonProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterAddonProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesClusterAddonProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesClusterAddonProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesClusterAddonProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesClusterProfileRequest struct {
	ctx                      _context.Context
	ApiService               *KubernetesApiService
	moid                     string
	kubernetesClusterProfile *KubernetesClusterProfile
	ifMatch                  *string
}

func (r KubernetesApiApiUpdateKubernetesClusterProfileRequest) KubernetesClusterProfile(kubernetesClusterProfile KubernetesClusterProfile) KubernetesApiApiUpdateKubernetesClusterProfileRequest {
	r.kubernetesClusterProfile = &kubernetesClusterProfile
	return r
}
func (r KubernetesApiApiUpdateKubernetesClusterProfileRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesClusterProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesClusterProfileRequest) Execute() (KubernetesClusterProfile, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesClusterProfileExecute(r)
}

/*
 * UpdateKubernetesClusterProfile Update a 'kubernetes.ClusterProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesClusterProfileRequest
 */
func (a *KubernetesApiService) UpdateKubernetesClusterProfile(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesClusterProfileRequest {
	return KubernetesApiApiUpdateKubernetesClusterProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesClusterProfile
 */
func (a *KubernetesApiService) UpdateKubernetesClusterProfileExecute(r KubernetesApiApiUpdateKubernetesClusterProfileRequest) (KubernetesClusterProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesClusterProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesClusterProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ClusterProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesClusterProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesClusterProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesClusterProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest struct {
	ctx                              _context.Context
	ApiService                       *KubernetesApiService
	moid                             string
	kubernetesContainerRuntimePolicy *KubernetesContainerRuntimePolicy
	ifMatch                          *string
}

func (r KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest) KubernetesContainerRuntimePolicy(kubernetesContainerRuntimePolicy KubernetesContainerRuntimePolicy) KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest {
	r.kubernetesContainerRuntimePolicy = &kubernetesContainerRuntimePolicy
	return r
}
func (r KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest) Execute() (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesContainerRuntimePolicyExecute(r)
}

/*
 * UpdateKubernetesContainerRuntimePolicy Update a 'kubernetes.ContainerRuntimePolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest
 */
func (a *KubernetesApiService) UpdateKubernetesContainerRuntimePolicy(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest {
	return KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesContainerRuntimePolicy
 */
func (a *KubernetesApiService) UpdateKubernetesContainerRuntimePolicyExecute(r KubernetesApiApiUpdateKubernetesContainerRuntimePolicyRequest) (KubernetesContainerRuntimePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesContainerRuntimePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesContainerRuntimePolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/ContainerRuntimePolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesContainerRuntimePolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesContainerRuntimePolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesContainerRuntimePolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesNetworkPolicyRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	moid                    string
	kubernetesNetworkPolicy *KubernetesNetworkPolicy
	ifMatch                 *string
}

func (r KubernetesApiApiUpdateKubernetesNetworkPolicyRequest) KubernetesNetworkPolicy(kubernetesNetworkPolicy KubernetesNetworkPolicy) KubernetesApiApiUpdateKubernetesNetworkPolicyRequest {
	r.kubernetesNetworkPolicy = &kubernetesNetworkPolicy
	return r
}
func (r KubernetesApiApiUpdateKubernetesNetworkPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesNetworkPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesNetworkPolicyRequest) Execute() (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesNetworkPolicyExecute(r)
}

/*
 * UpdateKubernetesNetworkPolicy Update a 'kubernetes.NetworkPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesNetworkPolicyRequest
 */
func (a *KubernetesApiService) UpdateKubernetesNetworkPolicy(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesNetworkPolicyRequest {
	return KubernetesApiApiUpdateKubernetesNetworkPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNetworkPolicy
 */
func (a *KubernetesApiService) UpdateKubernetesNetworkPolicyExecute(r KubernetesApiApiUpdateKubernetesNetworkPolicyRequest) (KubernetesNetworkPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNetworkPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesNetworkPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NetworkPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesNetworkPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesNetworkPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesNetworkPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest struct {
	ctx                        _context.Context
	ApiService                 *KubernetesApiService
	moid                       string
	kubernetesNodeGroupProfile *KubernetesNodeGroupProfile
	ifMatch                    *string
}

func (r KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest) KubernetesNodeGroupProfile(kubernetesNodeGroupProfile KubernetesNodeGroupProfile) KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest {
	r.kubernetesNodeGroupProfile = &kubernetesNodeGroupProfile
	return r
}
func (r KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest) Execute() (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesNodeGroupProfileExecute(r)
}

/*
 * UpdateKubernetesNodeGroupProfile Update a 'kubernetes.NodeGroupProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest
 */
func (a *KubernetesApiService) UpdateKubernetesNodeGroupProfile(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest {
	return KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesNodeGroupProfile
 */
func (a *KubernetesApiService) UpdateKubernetesNodeGroupProfileExecute(r KubernetesApiApiUpdateKubernetesNodeGroupProfileRequest) (KubernetesNodeGroupProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesNodeGroupProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesNodeGroupProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/NodeGroupProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesNodeGroupProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesNodeGroupProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesNodeGroupProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest struct {
	ctx                       _context.Context
	ApiService                *KubernetesApiService
	moid                      string
	kubernetesSysConfigPolicy *KubernetesSysConfigPolicy
	ifMatch                   *string
}

func (r KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest) KubernetesSysConfigPolicy(kubernetesSysConfigPolicy KubernetesSysConfigPolicy) KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest {
	r.kubernetesSysConfigPolicy = &kubernetesSysConfigPolicy
	return r
}
func (r KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest) Execute() (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesSysConfigPolicyExecute(r)
}

/*
 * UpdateKubernetesSysConfigPolicy Update a 'kubernetes.SysConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest
 */
func (a *KubernetesApiService) UpdateKubernetesSysConfigPolicy(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest {
	return KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesSysConfigPolicy
 */
func (a *KubernetesApiService) UpdateKubernetesSysConfigPolicyExecute(r KubernetesApiApiUpdateKubernetesSysConfigPolicyRequest) (KubernetesSysConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesSysConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesSysConfigPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/SysConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesSysConfigPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesSysConfigPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesSysConfigPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest struct {
	ctx                               _context.Context
	ApiService                        *KubernetesApiService
	moid                              string
	kubernetesTrustedRegistriesPolicy *KubernetesTrustedRegistriesPolicy
	ifMatch                           *string
}

func (r KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest) KubernetesTrustedRegistriesPolicy(kubernetesTrustedRegistriesPolicy KubernetesTrustedRegistriesPolicy) KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest {
	r.kubernetesTrustedRegistriesPolicy = &kubernetesTrustedRegistriesPolicy
	return r
}
func (r KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest) Execute() (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesTrustedRegistriesPolicyExecute(r)
}

/*
 * UpdateKubernetesTrustedRegistriesPolicy Update a 'kubernetes.TrustedRegistriesPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest
 */
func (a *KubernetesApiService) UpdateKubernetesTrustedRegistriesPolicy(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest {
	return KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesTrustedRegistriesPolicy
 */
func (a *KubernetesApiService) UpdateKubernetesTrustedRegistriesPolicyExecute(r KubernetesApiApiUpdateKubernetesTrustedRegistriesPolicyRequest) (KubernetesTrustedRegistriesPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesTrustedRegistriesPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesTrustedRegistriesPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/TrustedRegistriesPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesTrustedRegistriesPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesTrustedRegistriesPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesTrustedRegistriesPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesVersionRequest struct {
	ctx               _context.Context
	ApiService        *KubernetesApiService
	moid              string
	kubernetesVersion *KubernetesVersion
	ifMatch           *string
}

func (r KubernetesApiApiUpdateKubernetesVersionRequest) KubernetesVersion(kubernetesVersion KubernetesVersion) KubernetesApiApiUpdateKubernetesVersionRequest {
	r.kubernetesVersion = &kubernetesVersion
	return r
}
func (r KubernetesApiApiUpdateKubernetesVersionRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesVersionRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesVersionRequest) Execute() (KubernetesVersion, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesVersionExecute(r)
}

/*
 * UpdateKubernetesVersion Update a 'kubernetes.Version' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesVersionRequest
 */
func (a *KubernetesApiService) UpdateKubernetesVersion(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesVersionRequest {
	return KubernetesApiApiUpdateKubernetesVersionRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersion
 */
func (a *KubernetesApiService) UpdateKubernetesVersionExecute(r KubernetesApiApiUpdateKubernetesVersionRequest) (KubernetesVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/Versions/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVersion == nil {
		return localVarReturnValue, nil, reportError("kubernetesVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVersion
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesVersionPolicyRequest struct {
	ctx                     _context.Context
	ApiService              *KubernetesApiService
	moid                    string
	kubernetesVersionPolicy *KubernetesVersionPolicy
	ifMatch                 *string
}

func (r KubernetesApiApiUpdateKubernetesVersionPolicyRequest) KubernetesVersionPolicy(kubernetesVersionPolicy KubernetesVersionPolicy) KubernetesApiApiUpdateKubernetesVersionPolicyRequest {
	r.kubernetesVersionPolicy = &kubernetesVersionPolicy
	return r
}
func (r KubernetesApiApiUpdateKubernetesVersionPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesVersionPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesVersionPolicyRequest) Execute() (KubernetesVersionPolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesVersionPolicyExecute(r)
}

/*
 * UpdateKubernetesVersionPolicy Update a 'kubernetes.VersionPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesVersionPolicyRequest
 */
func (a *KubernetesApiService) UpdateKubernetesVersionPolicy(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesVersionPolicyRequest {
	return KubernetesApiApiUpdateKubernetesVersionPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVersionPolicy
 */
func (a *KubernetesApiService) UpdateKubernetesVersionPolicyExecute(r KubernetesApiApiUpdateKubernetesVersionPolicyRequest) (KubernetesVersionPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVersionPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesVersionPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VersionPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVersionPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesVersionPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVersionPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest struct {
	ctx                                       _context.Context
	ApiService                                *KubernetesApiService
	moid                                      string
	kubernetesVirtualMachineInfraConfigPolicy *KubernetesVirtualMachineInfraConfigPolicy
	ifMatch                                   *string
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest) KubernetesVirtualMachineInfraConfigPolicy(kubernetesVirtualMachineInfraConfigPolicy KubernetesVirtualMachineInfraConfigPolicy) KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest {
	r.kubernetesVirtualMachineInfraConfigPolicy = &kubernetesVirtualMachineInfraConfigPolicy
	return r
}
func (r KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest) Execute() (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesVirtualMachineInfraConfigPolicyExecute(r)
}

/*
 * UpdateKubernetesVirtualMachineInfraConfigPolicy Update a 'kubernetes.VirtualMachineInfraConfigPolicy' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineInfraConfigPolicy(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest {
	return KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfraConfigPolicy
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineInfraConfigPolicyExecute(r KubernetesApiApiUpdateKubernetesVirtualMachineInfraConfigPolicyRequest) (KubernetesVirtualMachineInfraConfigPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfraConfigPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesVirtualMachineInfraConfigPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfraConfigPolicies/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInfraConfigPolicy == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInfraConfigPolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInfraConfigPolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest struct {
	ctx                                            _context.Context
	ApiService                                     *KubernetesApiService
	moid                                           string
	kubernetesVirtualMachineInfrastructureProvider *KubernetesVirtualMachineInfrastructureProvider
	ifMatch                                        *string
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest) KubernetesVirtualMachineInfrastructureProvider(kubernetesVirtualMachineInfrastructureProvider KubernetesVirtualMachineInfrastructureProvider) KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest {
	r.kubernetesVirtualMachineInfrastructureProvider = &kubernetesVirtualMachineInfrastructureProvider
	return r
}
func (r KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest) Execute() (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesVirtualMachineInfrastructureProviderExecute(r)
}

/*
 * UpdateKubernetesVirtualMachineInfrastructureProvider Update a 'kubernetes.VirtualMachineInfrastructureProvider' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineInfrastructureProvider(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest {
	return KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInfrastructureProvider
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineInfrastructureProviderExecute(r KubernetesApiApiUpdateKubernetesVirtualMachineInfrastructureProviderRequest) (KubernetesVirtualMachineInfrastructureProvider, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInfrastructureProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesVirtualMachineInfrastructureProvider")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInfrastructureProviders/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInfrastructureProvider == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInfrastructureProvider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInfrastructureProvider
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest struct {
	ctx                                  _context.Context
	ApiService                           *KubernetesApiService
	moid                                 string
	kubernetesVirtualMachineInstanceType *KubernetesVirtualMachineInstanceType
	ifMatch                              *string
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest) KubernetesVirtualMachineInstanceType(kubernetesVirtualMachineInstanceType KubernetesVirtualMachineInstanceType) KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest {
	r.kubernetesVirtualMachineInstanceType = &kubernetesVirtualMachineInstanceType
	return r
}
func (r KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest) Execute() (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesVirtualMachineInstanceTypeExecute(r)
}

/*
 * UpdateKubernetesVirtualMachineInstanceType Update a 'kubernetes.VirtualMachineInstanceType' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineInstanceType(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest {
	return KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineInstanceType
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineInstanceTypeExecute(r KubernetesApiApiUpdateKubernetesVirtualMachineInstanceTypeRequest) (KubernetesVirtualMachineInstanceType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineInstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesVirtualMachineInstanceType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineInstanceTypes/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineInstanceType == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineInstanceType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineInstanceType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest struct {
	ctx                                 _context.Context
	ApiService                          *KubernetesApiService
	moid                                string
	kubernetesVirtualMachineNodeProfile *KubernetesVirtualMachineNodeProfile
	ifMatch                             *string
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest) KubernetesVirtualMachineNodeProfile(kubernetesVirtualMachineNodeProfile KubernetesVirtualMachineNodeProfile) KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest {
	r.kubernetesVirtualMachineNodeProfile = &kubernetesVirtualMachineNodeProfile
	return r
}
func (r KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest) IfMatch(ifMatch string) KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest) Execute() (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	return r.ApiService.UpdateKubernetesVirtualMachineNodeProfileExecute(r)
}

/*
 * UpdateKubernetesVirtualMachineNodeProfile Update a 'kubernetes.VirtualMachineNodeProfile' resource.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param moid The unique Moid identifier of a resource instance.
 * @return KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineNodeProfile(ctx _context.Context, moid string) KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest {
	return KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest{
		ApiService: a,
		ctx:        ctx,
		moid:       moid,
	}
}

/*
 * Execute executes the request
 * @return KubernetesVirtualMachineNodeProfile
 */
func (a *KubernetesApiService) UpdateKubernetesVirtualMachineNodeProfileExecute(r KubernetesApiApiUpdateKubernetesVirtualMachineNodeProfileRequest) (KubernetesVirtualMachineNodeProfile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  KubernetesVirtualMachineNodeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KubernetesApiService.UpdateKubernetesVirtualMachineNodeProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/kubernetes/VirtualMachineNodeProfiles/{Moid}"
	localVarPath = strings.Replace(localVarPath, "{"+"Moid"+"}", _neturl.PathEscape(parameterToString(r.moid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.kubernetesVirtualMachineNodeProfile == nil {
		return localVarReturnValue, nil, reportError("kubernetesVirtualMachineNodeProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.kubernetesVirtualMachineNodeProfile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
