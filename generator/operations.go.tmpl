// Code generated by generator-postprocess; DO NOT EDIT.

package gen

import (
    "fmt"
    "net/http"
    "regexp"
    "encoding/json"

    log "github.com/sirupsen/logrus"

    "github.com/cgascoig/isctl/pkg/util"
)

{{ define "cliitem" }}
{{ if .Operation }}{{ if not .Alias }}
    type {{ .Operation.OperationID }} struct {
    {{ if ne .BodyParamType "" }}body map[string]any{{ end }}
    }

    {{ if ne .BodyParamType "" }}
    func (o *{{ .Operation.OperationID }}) GetBody() map[string]any {
        if o.body == nil {
            o.body = map[string]any{}
            
            {{ if .HasBaseMo }}
            //Set class id and object type by default
            o.body["ClassId"] = "{{ .Operation.ReturnClassID }}"
            o.body["ObjectType"] = "{{ .Operation.ReturnClassID }}"
            {{ end }}
        }

        return o.body
    }
    {{ end }}

    func (o *{{ .Operation.OperationID }}) GetReferencedClasses(params map[string]any) ([]string, error) {
        {{ if ne .BodyParamType "" }}
        ret := []string{}

        {{ range .Operation.MoRefs }}
        {{ if .IsList }}
        // Handle list of MoRef for {{ .Path }} with type {{ .DataType }}

        if refList, err := dyno.GetSlice(params{{range .Path }}, "{{ . }}"{{ end }}); err == nil {
            for _, item := range refList {
                if refStr, ok := item.(string); ok {
                    classId := RelationshipToIntersightClassId("{{ .DataType }}")
                    _, _, isMoFilter := util.ParseMoRef(refStr) // TODO - should hande datatype from here too
                    if isMoFilter && classId != "" {
                        ret = append(ret, classId)
                    }
                }
            }
        }

        {{ else }}
        // Handle MoRef for {{ .Path }} with type {{ .DataType }}
        if refAny, err := dyno.Get(params{{range .Path }}, "{{ . }}"{{ end }}); err == nil {
            if refStr, ok := refAny.(string); ok {
                classId := RelationshipToIntersightClassId("{{ .DataType }}")
                _, _, isMoFilter := util.ParseMoRef(refStr)  // TODO - should hande datatype from here too
                if isMoFilter && classId != "" {
                    ret = append(ret, classId)
                }
            }
        }
        {{ end }}
        {{ end }}

        return ret, nil

        {{ else }}return []string{}, nil{{ end }}
    }


    func (o *{{ .Operation.OperationID }}) SetBodyParams(client *util.IsctlClient, params map[string]any) error {
        {{ if ne .BodyParamType "" }}
        // MoRefs: {{ .Operation.MoRefs }}

        log.Tracef("SetBodyParams: input params: %#v", params)
        params["ClassId"] = "{{ .Operation.ReturnClassID }}"
        params["ObjectType"] = "{{ .Operation.ReturnClassID }}"

        {{ range .Operation.MoRefs }}
        {{ if .IsList }}
        // Try to resolve list of MoRef for {{ .Path }} with type {{ .DataType }}
        log.Tracef("list {{ .Path }}")

        if refList, err := dyno.GetSlice(params{{range .Path }}, "{{ . }}"{{ end }}); err == nil {
            log.Tracef("list {{ .Path }} A %v", refList)
            newList := []any{}
            for _, item := range refList {
                log.Tracef("list {{ .DataType }} B")
                if refStr, ok := item.(string); ok {
                    log.Tracef("list {{ .DataType }} C")
                    filter, datatype, isMoFilter := util.ParseMoRef(refStr)
                    if isMoFilter {
                        log.Tracef("list {{ .DataType }} D")
                        var moref map[string]any
                        if datatype != "" {
                            moref = setMoMoRefByFilter(client, datatype, filter)
                        } else {
                            moref = setMoMoRefByFilter(client, "{{ .DataType }}", filter)
                        }

                        if moref != nil {
                            newList = append(newList, moref)
                        } else {
                            return fmt.Errorf("Error retreiving relationship: %s", refStr)
                        }
                    }
                } else {
                    newList = append(newList, item)
                }
            }
            dyno.Set(params, newList{{range .Path }}, "{{ . }}"{{ end }})
        } else { log.Tracef("dyno error for {{ .Path }}: %v", err)}
        {{ else }}
        // Try to resolve MoRef for {{ .Path }} with type {{ .DataType }}

        if refAny, err := dyno.Get(params{{range .Path }}, "{{ . }}"{{ end }}); err == nil {
            if refStr, ok := refAny.(string); ok {
                filter, datatype, isMoFilter := util.ParseMoRef(refStr)
                if isMoFilter {
                    var moref map[string]any
                    if datatype != "" {
                        moref = setMoMoRefByFilter(client, datatype, filter)
                    } else {
                        moref = setMoMoRefByFilter(client, "{{ .DataType }}", filter)
                    }

                    if moref != nil {
                        dyno.Set(params, moref{{range .Path }}, "{{ . }}"{{ end }})
                    } else {
                        return fmt.Errorf("Error retreiving relationship: %s", refStr)
                    }
                }
            }
        }
        {{ end }}
        {{ end }}

        log.Tracef("SetBodyParams: after relationship resolving: %v", params)

        o.body = params
        return nil
        {{ else }}return nil{{ end }}
    }

    func (o *{{ .Operation.OperationID }}) Execute(client *util.IsctlClient, args []string, queryParams map[string]string) (interface{}, error) {
        {{ if ne .BodyParamType "" }}
        js, err := json.Marshal(o.body)
        if err != nil {
            return nil, fmt.Errorf("unable to marshal request body")
        }
        {{ else }}
        js := []byte("")
        {{ end }}
        path, err := ReplaceArgs("{{ .Operation.Path }}", args)
        if err != nil {
            return nil, err
        }
        queryString := EncodeQueryParams(queryParams)
        if queryString != "" {
            path = fmt.Sprintf("%s?%s", path, queryString)
        }
        res, err := client.IntersightClient.Call("{{ .Operation.HTTPMethod }}", path, js)
        {{ if ne .Operation.ReturnType "" }}
        return res, err
        {{ else }}
        return res, err
        {{ end }}
    }
{{ end }}{{ end }}

{{ range $k, $v := .Children }}{{ template "cliitem" $v}}{{ end }}
{{ end }}

{{ template "cliitem" .CliTree }}


func GetOperationForRelationship(relationship string) Operation {
    r := regexp.MustCompile(`Relationship$`)
    relationship = r.ReplaceAllString(relationship, "Response")

    // Strip "[]" at the start if needed
    r2 := regexp.MustCompile(`^\[\]`)
    relationship = r2.ReplaceAllString(relationship, "")

    switch relationship {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsListOperation }}
        case "{{ .ReturnType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func GetGetOperationForClassID(classID string) Operation {
    classID = fmt.Sprintf("%s.Response", classID)

    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsListOperation }}
        case "{{ .ReturnClassID }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func GetUpdateOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsUpdateOperation }}
        case "{{ .ReturnClassID }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func GetCreateOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsCreateOperation }}
        case "{{ .ReturnClassID }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func GetDeleteOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if .IsDeleteOperation }}
        case "{{ .DeleteOperationDataType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}
    }

    return nil
}
