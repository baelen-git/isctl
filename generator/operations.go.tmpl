// Code generated by generator-postprocess; DO NOT EDIT.

package main

import (
    "fmt"
    "net/http"
    "regexp"
    "encoding/json"
    "reflect"

    log "github.com/sirupsen/logrus"
    openapi "github.com/CiscoDevNet/intersight-go"
)

{{ define "cliitem" }}
{{ if .Operation }}{{ if not .Alias }}
    type {{ .Operation.OperationID }} struct {
    {{ if ne .BodyParamType "" }}body *openapi.{{ .BodyParamType }}{{ end }}
    }

    {{ if ne .BodyParamType "" }}
    func (o *{{ .Operation.OperationID }}) GetBody() *openapi.{{ .BodyParamType }} {
        if o.body == nil {
            o.body = &openapi.{{ .BodyParamType }}{}
            
            {{ if .HasBaseMo }}
            //Set class id and object type by default
            o.body.ClassId = "{{ .Operation.ReturnClassID }}"
            o.body.ObjectType = "{{ .Operation.ReturnClassID }}"
            {{ end }}
        }

        return o.body
    }
    {{ end }}

    func (o *{{ .Operation.OperationID }}) GetReferencedClasses(params map[string]interface{}) ([]string, error) {
        {{ if ne .BodyParamType "" }}
        ret := []string{}
        {{ range .BodyParamVars }}
        {{ if eq .DataType "string" "bool" "[]string" "int64" "[]int64" "int32" "float64" "float32" "[]float32" }}{{ else }}{{ if .ValidGenericType }}
            if v, ok := params["{{ .Name }}"]; ok && isMoRef({{ .NormalisedType }}{}) {
                if refStr, ok := v.(string); ok {
                    paramVal := {{ .NormalisedType }}{}

                    if _, _, isMoFilter := parseMoRef(refStr); isMoFilter {
                        ret = append(ret, goTypeNameToIntersightClassID[getReferredTypeName(reflect.ValueOf(paramVal).Type())])
                    }
                }
            }
        {{ end }}{{ if .IsList }}
            // handle list
            if v, ok := params["{{ .Name }}"]; ok && isMoRef(openapi.{{ .ListElementType }}{}) {
                if l, ok := v.([]interface{}); ok {
                    for _, item := range l {
                        if refStr, ok := item.(string); ok {
                            paramVal := openapi.{{ .ListElementType }}{}

                            _, _, isMoFilter := parseMoRef(refStr)
                            if isMoFilter {
                                ret = append(ret, goTypeNameToIntersightClassID[getReferredTypeName(reflect.ValueOf(paramVal).Type())])
                            }
                        }
                    }
                }
            }
        {{ end }}
        {{ end }}
        {{ end }}

        return ret, nil
        {{ else }}return []string{}, nil{{ end }}
    }


    func (o *{{ .Operation.OperationID }}) SetBodyParams(client *openapi.APIClient, params map[string]interface{}) error {
        {{ if ne .BodyParamType "" }}
        body := o.GetBody()

        log.Tracef("SetBodyParams: input params: %v", params)
        params["ClassId"] = "{{ .Operation.ReturnClassID }}"
        params["ObjectType"] = "{{ .Operation.ReturnClassID }}"

        {{ range .BodyParamVars }}
        {{ if eq .DataType "string" "bool" "[]string" "int64" "[]int64" "int32" "float64" "float32" "[]float32" }}{{ else }}{{ if .ValidGenericType }}
            if v, ok := params["{{ .Name }}"]; ok {
                if complexValue, ok := v.(*ComplexValue); ok {
                    paramVal := {{ .NormalisedType }}{}

                    err := json.Unmarshal([]byte(complexValue.String()), &paramVal)
                    if err != nil {
                        return fmt.Errorf("Error parsing complex (JSON) value: %v", err)
                    }

                    params["{{ .Name }}"] = &paramVal
                } else if isMoRef({{ .NormalisedType }}{}) {
                    if refStr, ok := v.(string); ok {
                        paramVal := {{ .NormalisedType }}{}

                        filter, datatype, isMoFilter := parseMoRef(refStr)
                        if isMoFilter {
                            var ok bool
                            if datatype != "" {
                                ok = setMoMoRefByFilter(client, &paramVal, datatype, filter)
                            } else {
                                ok = setMoMoRefByFilter(client, &paramVal, "{{ .DataType }}", filter)
                            }

                            if ok {
                                params["{{ .Name }}"] = &paramVal
                            } else {
                                return fmt.Errorf("Error retreiving relationship: %s", refStr)
                            }
                        } else {
                            return fmt.Errorf("Error parsing relationship: %s", refStr)
                        }
                    }
                }
            }

            
        {{ end }}{{ if .IsList }}
            // handle list
            if v, ok := params["{{ .Name }}"]; ok && isMoRef(openapi.{{ .ListElementType }}{}) {
                if l, ok := v.([]interface{}); ok {
                    newList := []interface{}{}
                    for _, item := range l {
                        if refStr, ok := item.(string); ok {
                            paramVal := openapi.{{ .ListElementType }}{}

                            filter, datatype, isMoFilter := parseMoRef(refStr)
                            if isMoFilter {
                                var ok bool
                                if datatype != "" {
                                    ok = setMoMoRefByFilter(client, &paramVal, datatype, filter)
                                } else {
                                    ok = setMoMoRefByFilter(client, &paramVal, "{{ .ListElementType }}", filter)
                                }

                                if ok {
                                    newList = append(newList, &paramVal)
                                } else {
                                    return fmt.Errorf("Error retreiving relationship: %s", refStr)
                                }
                            } else {
                                return fmt.Errorf("Error parsing relationship: %s", refStr)
                            }
                        } else {
                            newList = append(newList, item)
                        }
                    }
                    params["{{ .Name }}"] = newList
                }
            }
        {{ end }}
        {{ end }}
        {{ end }}

        log.Tracef("SetBodyParams: after relationship resolving: %v", params)

        jsTmp, err := json.Marshal(params)
        if err != nil {
            return fmt.Errorf("SetBodyParams: Error marshalling JSON: %v", err)
        }

        log.Tracef("SetBodyParams: intermediary JSON: %s", jsTmp)
        
        err = json.Unmarshal(jsTmp, body)
        if err != nil {
            return fmt.Errorf("SetBodyParams: Error unmarshalling JSON: %v", err)
        }

        //o.body = body
        return nil
        {{ else }}return nil{{ end }}
    }

    func (o *{{ .Operation.OperationID }}) Execute(client *openapi.APIClient, args []string, queryParams map[string]string) (interface{}, *http.Response, error) {
        req := client.{{ .Operation.BaseName }}Api.{{ .Operation.OperationID }}(authCtx{{ if .Parameter }}, args[0]{{ end }})

        {{ if ne .BodyParamType "" }}log.Tracef("o.body: %v", o.body)
        req = req.{{ .BodyParamType }}(*o.body){{ end }}

        {{ if eq .Operation.HTTPMethod "GET" }}
            {{ if not .Parameter }}
                if filter, ok := queryParams["filter"]; ok && filter != "" {
                    req = req.Filter(filter)
                }

                if sel, ok := queryParams["select"]; ok && sel != "" {
                    req = req.Select_(sel)
                }

                if expand, ok := queryParams["expand"]; ok && expand != "" {
                    req = req.Expand(expand)
                }

                if orderby, ok := queryParams["orderby"]; ok && orderby != "" {
                    req = req.Orderby(orderby)
                }

                if top, ok := queryParams["top"]; ok && top != "" {
                    topInt, err := strconv.Atoi(top)
                    if err == nil {
                        req = req.Top(int32(topInt))
                    } else {
                        log.Fatalf("top must be an integer")
                    }
                }

                if skip, ok := queryParams["skip"]; ok && skip != "" {
                    skipInt, err := strconv.Atoi(skip)
                    if err == nil {
                        req = req.Skip(int32(skipInt))
                    } else {
                        log.Fatalf("skip must be an integer")
                    }
                }

                if name, ok := queryParams["name"]; ok && name != "" {
                    req = req.Filter(fmt.Sprintf("Name eq '%s'", name))
                }
            {{ end }}

        {{ end }}

        {{ if ne .Operation.ReturnType "" }}
        res, httpResponse, err := req.Execute()
        return res, httpResponse, err
        {{ else }}
        httpResponse, err := req.Execute()
        return nil, httpResponse, err
        {{ end }}
    }
{{ end }}{{ end }}

{{ range $k, $v := .Children }}{{ template "cliitem" $v}}{{ end }}
{{ end }}

{{ template "cliitem" .CliTree }}


func getOperationForRelationship(relationship string) Operation {
    r := regexp.MustCompile(`Relationship$`)
    relationship = r.ReplaceAllString(relationship, "Response")
    switch relationship {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsListOperation }}
        case "{{ .ReturnType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func getGetOperationForClassID(classID string) Operation {
    classID = fmt.Sprintf("%s.Response", classID)

    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsListOperation }}
        case "{{ .ReturnClassID }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func getUpdateOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsUpdateOperation }}
        case "{{ .ReturnClassID }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func getCreateOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if ne .ReturnType "" }}{{ if .IsCreateOperation }}
        case "{{ .ReturnClassID }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}{{ end }}
    }

    return nil
}

func getDeleteOperationForClassID(classID string) Operation {
    switch classID {
    {{ range .Operations }}{{ if .IsDeleteOperation }}
        case "{{ .DeleteOperationDataType }}":
            return &{{ .OperationID }}{}
    {{ end }}{{ end }}
    }

    return nil
}
