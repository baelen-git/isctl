// Code generated by generator-postprocess; DO NOT EDIT.

package main

import (
	"fmt"
	"net/http"
	"reflect"
    "regexp"

    log "github.com/sirupsen/logrus"
    openapi "github.com/cgascoig/intersight-go-sdk/intersight"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)


{{ define "cliitem" }}
func () *cobra.Command {
    cmd := &cobra.Command{
        Use: "{{ .Token }}",
        {{ if .Operation }}
        Run: func(cmd *cobra.Command, args []string) {
            client.GetConfig().Debug = verbose

            // singleResult is true if the query should return a single result - used to decide whether to collapse the result into an object or single entry list for display/jsonpath processing
            var singleResult = false

            {{ if eq .Parameter "name" }}
            singleResult = true
            // Lookup moid from name
            getOp := getGetOperationForClassID("{{ .Operation.ReturnClassID }}")
            if getOp == nil {
                resultHandler(nil, nil, fmt.Errorf("FATAL: No operation to lookup Moid from '{{ .Operation.ReturnClassID }}'"))
                return
            }
            res, _, err := getOp.Execute(client, nil, map[string]string{"filter": fmt.Sprintf("Name eq '%s'", args[0])})
            if err != nil {
                resultHandler(nil, nil, fmt.Errorf("Error executing query to lookup Moid from Name: %v", err))
                return 
            }

            moid, ok := getMoid(res)
            if !ok {
                resultHandler(nil, nil, fmt.Errorf("Error executing query to lookup Moid from Name: number of results must exactly equal 1"))
                return 
            }

            args = []string{moid}
            {{ end }}

            bodyParamMap := map[string]interface{}{}

            bodyFormat, err := cmd.Flags().GetString("bodyformat")
            if err == nil && bodyFormat != "" {
                err = readBody(bodyFormat, &bodyParamMap)
                if err != nil {
                    resultHandler(nil, nil, fmt.Errorf("Error reading body from standard input: %v", err))
                    return
                }
            }

            operation := {{ .Operation.OperationID }}{}

            flagSetToMap(cmd.Flags(), &bodyParamMap)
            if err = operation.SetBodyParams(client, bodyParamMap); err != nil {
                resultHandler(nil, nil, fmt.Errorf("Generating API body: %v", err))
                return
            }

            queryParams := map[string]string{}
            {{ if eq .Operation.HTTPMethod "GET" }}
                {{ if not .Parameter }}
                    queryParams = getQueryParams(cmd.Flags())
                    if _, ok := queryParams["name"]; ok {
                        singleResult = true
                    }
                {{ end }}
            {{ end }}

            res, httpResponse, err := operation.Execute(client, args, queryParams)
            resultHandler(res, httpResponse, err, ResultOpt{SingleResult: &singleResult})
        }, 
        {{ end }}
        {{ if .Parameter }}
        Args: cobra.ExactArgs(1),
        {{ end }}
        
        Short: "{{ .Help }}",
        Long: `{{ .Help }}
{{ if ne .BodyParamType "" }}
Provide resource body as JSON on standard input{{ end }}`,
    }
    
    {{ range $k, $v := .Children }}
        cmd.AddCommand({{ template "cliitem" $v}}())
    {{ end }}

    {{ if ne .BodyParamType "" }}
        cmd.Flags().String("bodyformat", "", "Format of request body passed on stdin (e.g. \"json\"). Default: don't read from stdin")
    {{ end }}

    {{ range .BodyParamVars }}
        {{ if eq .DataType "string" }}
            cmd.Flags().String("{{ .Name }}", "", "{{ .Name }}")
        {{ else if eq .DataType "bool" }}
            cmd.Flags().Bool("{{ .Name }}", false, "{{ .Name }}")
        {{ else if eq .DataType "[]string" }}
            cmd.Flags().StringSlice("{{ .Name }}", []string{}, "{{ .Name }}")
        {{ else if eq .DataType "int64" }}
            cmd.Flags().Int64("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "[]int64" }}
            cmd.Flags().Int64Slice("{{ .Name }}", []int64{}, "{{ .Name }}")
        {{ else if eq .DataType "int32" }}
            cmd.Flags().Int("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "float64" }}
            cmd.Flags().Float64("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "float32" }}
            cmd.Flags().Float32("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "[]float32" }}
            cmd.Flags().Float32Slice("{{ .Name }}", []float32{}, "{{ .Name }}")
        {{ else if .ValidGenericType }}
            if isMoRef({{ .NormalisedType }}{}) {
                cmd.Flags().String("{{ .Name }}", "", "{{ .Name }}")
            } else {
                cmd.Flags().Var(&ComplexValue{}, "{{ .Name }}", "{{ .Name }} as JSON")
            }
        {{ else }} //Skipping unhandled param type {{ .DataType }}
        {{ end }}
    {{ end }}

    {{ if .Operation }}
        {{ if eq .Operation.HTTPMethod "GET" }}
            {{ if not .Parameter }}
                cmd.Flags().String("filter", "", "Filter query (e.g. \"Name eq 'Bob'\" - note the inner quotes must be single-quotes)")
                cmd.Flags().String("select", "", "Select which attributes the API should return")
                cmd.Flags().String("name", "", "Filter by exact name (note: if both --filter and --name are supplied, --name takes precedence")
            {{ end }}
        {{ end }}
    {{ end }}

    return cmd
}{{ end }}

func getQueryParams(flagset *pflag.FlagSet) map[string]string {
    queryParams := map[string]string{}

    if filter, err := flagset.GetString("filter"); err == nil && filter != "" {
        queryParams["filter"] = filter
    }

    if sel, err := flagset.GetString("select"); err == nil && sel != "" {
        queryParams["select"] = sel
    }

    if name, err := flagset.GetString("name"); err == nil && name != "" {
        queryParams["name"] = name
    }

    return queryParams
}

func flagSetToMap(flagset *pflag.FlagSet, ret *map[string]interface{}) {
    flagset.Visit(func(f *pflag.Flag) {

        // Filter out isctl flags that aren't body parameters (all body params are capitalised)
        paramRe := regexp.MustCompile(`^[A-Z]`)
        if !paramRe.MatchString(f.Name) {
            return
        }

        switch f.Value.Type() {
        case "string":
            (*ret)[f.Name], _ = flagset.GetString(f.Name)
        case "bool":
            (*ret)[f.Name], _ = flagset.GetBool(f.Name)
        case "stringSlice":
            (*ret)[f.Name], _ = flagset.GetStringSlice(f.Name)
        case "int64":
            (*ret)[f.Name], _ = flagset.GetInt64(f.Name)
        case "[]int64":
            (*ret)[f.Name], _ = flagset.GetInt64Slice(f.Name)
        case "int32":
            (*ret)[f.Name], _ = flagset.GetInt(f.Name)
        case "float64":
            (*ret)[f.Name], _ = flagset.GetFloat64(f.Name)
        case "float32":
            (*ret)[f.Name], _ = flagset.GetFloat32(f.Name)
        case "json":
            (*ret)[f.Name] = f.Value
        default:
            log.Warnf("Unknown type for %s flag", f.Name )
        }
    })

    return
}

func isFlagPassed(flagset *pflag.FlagSet, name string) bool {
    found := false
    flagset.Visit(func(f *pflag.Flag) {
        if f.Name == name {
            found = true
        }
    })
    return found
}

func isMoRef(v interface{}) bool {
    val := reflect.Indirect(reflect.ValueOf(v))
	t := val.Type()
	if t.Kind() != reflect.Struct {
		return false
	}

	_, ok := t.FieldByName("MoMoRef")

	return ok
}

func setMoRefSelector(v interface{}, selector string) bool {
    if !isMoRef(v) {
        return false
    }

    moref := new(openapi.MoMoRef)
    moref.ClassId = "mo.MoRef"
    moref.Selector = &selector

    val := reflect.ValueOf(v).Elem()

    // Here we are trying to find the type of the field other than MoMoRef (e.g. OrganizationOrganization)
    // i.e. the type that this MoRef refers to
    t := val.Type()
    var referredTypeName string
    for i := 0; i < t.NumField(); i++ {
        if t.Field(i).Name == "MoMoRef" {
            continue
        }
        referredTypeName = t.Field(i).Type.Elem().Name()
    }

    moref.ObjectType = goTypeNameToIntersightClassID[referredTypeName]

    val.FieldByName("MoMoRef").Set(reflect.ValueOf(moref))

    return true
}

func runCmd(cmd *cobra.Command, args []string) {
    log.Printf("Running command %s with args %v", cmd.Use, args)
}

// ResultHandler is the function signature to handle API results
type ResultHandler = func(result interface{}, httpResponse *http.Response, err error, opts ...ResultOpt)

// GetCommands returns the cobra command tree for the API
func GetCommands(client *openapi.APIClient, resultHandler ResultHandler) *cobra.Command {
    rootCmd := {{ template "cliitem" .CliTree }}()
    return rootCmd
}
