// Code generated by generator-postprocess; DO NOT EDIT.

package gen

import (
	"fmt"
	"net/http"
	"reflect"
    "regexp"

    log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
    "github.com/cgascoig/isctl/pkg/util"
)


{{ define "cliitem" }}
func () *cobra.Command {
    cmd := &cobra.Command{
        Use: "{{ .Token }}",
        {{ if .Operation }}
        Run: func(cmd *cobra.Command, args []string) {
            // client.GetConfig().Debug = verbose

            // singleResult is true if the query should return a single result - used to decide whether to collapse the result into an object or single entry list for display/jsonpath processing
            var singleResult = false

            {{ if eq .Parameter "name" }}
            singleResult = true
            // Lookup moid from name
            getOp := GetGetOperationForClassID("{{ .Operation.ReturnClassID }}")
            if getOp == nil {
                resultHandler(nil, nil, fmt.Errorf("FATAL: No operation to lookup Moid from '{{ .Operation.ReturnClassID }}'"))
                return
            }
            res, _, err := getOp.Execute(client, nil, map[string]string{"filter": fmt.Sprintf("Name eq '%s'", args[0])})
            if err != nil {
                resultHandler(nil, nil, fmt.Errorf("Error executing query to lookup Moid from Name: %v", err))
                return 
            }

            moid, ok := util.GetMoid(res)
            if !ok {
                resultHandler(nil, nil, fmt.Errorf("Error executing query to lookup Moid from Name: number of results must exactly equal 1"))
                return 
            }

            args = []string{moid}
            {{ end }}

            bodyParamMap := map[string]interface{}{}

            bodyFormat, err := cmd.Flags().GetString("bodyformat")
            if err == nil && bodyFormat != "" {
                err = util.ReadBody(bodyFormat, &bodyParamMap)
                if err != nil {
                    resultHandler(nil, nil, fmt.Errorf("Error reading body from standard input: %v", err))
                    return
                }
            }

            operation := {{ .Operation.OperationID }}{}

            flagSetToMap(cmd.Flags(), &bodyParamMap)
            if err = operation.SetBodyParams(client, bodyParamMap); err != nil {
                resultHandler(nil, nil, fmt.Errorf("Generating API body: %v", err))
                return
            }

            queryParams := map[string]string{}
            {{ if eq .Operation.HTTPMethod "GET" }}
                {{ if not .Parameter }}
                    queryParams = getQueryParams(cmd.Flags())
                    if isFlagPassed(cmd.Flags(), "name") {
                        singleResult = true
                    }
                {{ end }}
            {{ end }}

            res, httpResponse, err := operation.Execute(client, args, queryParams)
            resultHandler(res, httpResponse, err, util.ResultOpt{SingleResult: &singleResult})
        }, 
        {{ end }}
        {{ if .Parameter }}
        Args: cobra.ExactArgs(1),
        {{ end }}
        
        Short: "{{ .Help }}",
        Long: `{{ .Help }}
{{ if ne .BodyParamType "" }}
Provide resource body as JSON on standard input{{ end }}`,
    }
    
    {{ range $k, $v := .Children }}
        cmd.AddCommand({{ template "cliitem" $v}}())
    {{ end }}

    {{ if ne .BodyParamType "" }}
        cmd.Flags().String("bodyformat", "", "Format of request body passed on stdin (e.g. \"json\"). Default: don't read from stdin")
    {{ end }}

    {{ range .BodyParamVars }}
        {{ if eq .DataType "string" }}
            cmd.Flags().String("{{ .Name }}", "", "{{ .Name }}")
        {{ else if eq .DataType "bool" }}
            cmd.Flags().Bool("{{ .Name }}", false, "{{ .Name }}")
        {{ else if eq .DataType "[]string" }}
            cmd.Flags().StringSlice("{{ .Name }}", []string{}, "{{ .Name }}")
        {{ else if eq .DataType "int64" }}
            cmd.Flags().Int64("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "[]int64" }}
            cmd.Flags().Int64Slice("{{ .Name }}", []int64{}, "{{ .Name }}")
        {{ else if eq .DataType "int32" }}
            cmd.Flags().Int("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "float64" }}
            cmd.Flags().Float64("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "float32" }}
            cmd.Flags().Float32("{{ .Name }}", 0, "{{ .Name }}")
        {{ else if eq .DataType "[]float32" }}
            cmd.Flags().Float32Slice("{{ .Name }}", []float32{}, "{{ .Name }}")
        {{ else if .ValidGenericType }}
            if false /*isMoRef({{ .NormalisedType }}{})*/ { // TODO - need to fix isMoRef
                cmd.Flags().String("{{ .Name }}", "", "{{ .Name }}")
            } else {
                cmd.Flags().Var(&util.ComplexValue{}, "{{ .Name }}", "{{ .Name }} as JSON")
            }
        {{ else if eq .DataType "" }}
            cmd.Flags().Var(&util.ComplexValue{}, "{{ .Name }}", "{{ .Name }} as JSON")
        {{ else }} //Skipping unhandled param '{{ .Name }}' with type '{{ .DataType }}'
        {{ end }}
    {{ end }}

    {{ if .Operation }}
        {{ if eq .Operation.HTTPMethod "GET" }}
            {{ if not .Parameter }}
                cmd.Flags().String("filter", "", "Filter query (e.g. \"Name eq 'Bob'\" - note the inner quotes must be single-quotes)")
                cmd.Flags().String("select", "", "Select which attributes the API should return")
                cmd.Flags().String("expand", "", "Expand query https://intersight.com/apidocs/introduction/query/#expand-query-option-returning-related-resources")
                cmd.Flags().String("orderby", "", "Sort returned results (e.g. \"CreateTime desc\")")
                cmd.Flags().String("top", "", "Maximum number of results to return. Use with --skip for pagination of results")
                cmd.Flags().String("skip", "", "Number of objects to skip and not include in results. Use with --top for pagination of results")
                cmd.Flags().String("name", "", "Filter by exact name (note: if both --filter and --name are supplied, --name takes precedence")
            {{ end }}
        {{ end }}
    {{ end }}

    return cmd
}{{ end }}

func getQueryParams(flagset *pflag.FlagSet) map[string]string {
    queryParams := map[string]string{}

    if filter, err := flagset.GetString("filter"); err == nil && filter != "" {
        queryParams["filter"] = filter
    }

    if sel, err := flagset.GetString("select"); err == nil && sel != "" {
        queryParams["select"] = sel
    }

    if expand, err := flagset.GetString("expand"); err == nil && expand != "" {
        queryParams["expand"] = expand
    }

    if orderby, err := flagset.GetString("orderby"); err == nil && orderby != "" {
        queryParams["orderby"] = orderby
    }

    if top, err := flagset.GetString("top"); err == nil && top != "" {
        queryParams["top"] = top
    }

    if skip, err := flagset.GetString("skip"); err == nil && skip != "" {
        queryParams["skip"] = skip
    }

    if name, err := flagset.GetString("name"); err == nil && name != "" {
        queryParams["filter"] = fmt.Sprintf("Name eq '%s'", name)
    }

    return queryParams
}

func flagSetToMap(flagset *pflag.FlagSet, ret *map[string]interface{}) {
    flagset.Visit(func(f *pflag.Flag) {

        // Filter out isctl flags that aren't body parameters (all body params are capitalised)
        paramRe := regexp.MustCompile(`^[A-Z]`)
        if !paramRe.MatchString(f.Name) {
            return
        }

        switch f.Value.Type() {
        case "string":
            (*ret)[f.Name], _ = flagset.GetString(f.Name)
        case "bool":
            (*ret)[f.Name], _ = flagset.GetBool(f.Name)
        case "stringSlice":
            (*ret)[f.Name], _ = flagset.GetStringSlice(f.Name)
        case "int64":
            (*ret)[f.Name], _ = flagset.GetInt64(f.Name)
        case "[]int64":
            (*ret)[f.Name], _ = flagset.GetInt64Slice(f.Name)
        case "int32":
            (*ret)[f.Name], _ = flagset.GetInt(f.Name)
        case "float64":
            (*ret)[f.Name], _ = flagset.GetFloat64(f.Name)
        case "float32":
            (*ret)[f.Name], _ = flagset.GetFloat32(f.Name)
        case "json":
            var paramVal any

            err := json.Unmarshal([]byte(f.Value.String()), &paramVal)
            if err == nil {
                (*ret)[f.Name] = paramVal
            } else {
                (*ret)[f.Name] = f.Value.String()
            }
        default:
            log.Warnf("Unknown type for %s flag", f.Name )
        }
    })

    return
}

func isFlagPassed(flagset *pflag.FlagSet, name string) bool {
    found := false
    flagset.Visit(func(f *pflag.Flag) {
        if f.Name == name {
            found = true
        }
    })
    return found
}

func runCmd(cmd *cobra.Command, args []string) {
    log.Printf("Running command %s with args %v", cmd.Use, args)
}

// ResultHandler is the function signature to handle API results
type ResultHandler = func(result interface{}, httpResponse *http.Response, err error, opts ...util.ResultOpt)

// GetCommands returns the cobra command tree for the API
func GetCommands(client *util.IsctlClient, resultHandler ResultHandler) *cobra.Command {
    rootCmd := {{ template "cliitem" .CliTree }}()
    return rootCmd
}
